<!DOCTYPE html>
<html>
<head>
	<title>WebGL Multiplayer Target</title>

	<link rel="stylesheet" type="text/css" href="index_style.css">
	
	<script src="jquery-1.7.2.min.js"></script>

	<script src="three.js-master/build/three.js"></script>

	<script src="three.js-master/examples/js/renderers/Projector.js"></script>
	<script src="three.js-master/examples/js/libs/ammo.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script src="three.js-master/examples/js/WebGL.js"></script>
	<script src="three.js-master/examples/js/ConvexObjectBreaker.js"></script>
	<script src="three.js-master/examples/js/QuickHull.js"></script>
	<script src="three.js-master/examples/js/geometries/ConvexGeometry.js"></script>
	<script src="three.js-master/examples/js/loaders/PLYLoader.js"></script>
	
	<script src="three.js-master/src/loaders/TextureLoader.js"></script>
	<script src="Three.FirstPersonControls.js"></script>

	<script src="Player.js"></script>
</head>

<body>
</body>

<script>

// Initalize the map where '1' represents a "wall".
var map = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]];
var mapW = map.length;
var mapH = map[0].length;

// Semi-constants
var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;
var ASPECT_RATIO = WIDTH / HEIGHT;
var UNIT_SIZE = 250;
var BULLET_SPEED = 500;
var PROJECTILE_DAMAGE = 20;
var ARROW_SPEED = 1;
var GRAVITY = 9.81;

// Global vars
var scene, cam, backgroundScene, backgroundCamera, renderer, controls, clock, projector, model, skin;
var runAnim = true;
var mouseCoords = new THREE.Vector2();
var container, stats;
var textureLoader;
var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
var loader = new THREE.PLYLoader();
var mousedownID = -1;
var pow = .1;

// Holds the Player objects for our game.
var players = [];

var player1;
var player2;

// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;
var wind;

var rigidBodies = [];
var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
var time = 0;
var objectsToRemove = [];
for ( var i = 0; i < 500; i++ ) 
{
	objectsToRemove[ i ] = null;
}
var numObjectsToRemove = 0;
var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();
var hBar = $('.health-bar');
var bar = hBar.find('.bar');
var hit = hBar.find('.hit');
var pBar = $('.power-bar'),
power = pBar.find('.power');

// Initialize and run on document ready
$(document).ready(function() 
{
	$('body').append('<div id="intro">Click to start</div>');
	$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) 
	{
		e.preventDefault();
		$(this).fadeOut();
		 init();
		 initWind();
		 initPhysics();
		//setInterval(drawWind, 1000);
		animate();
	});
});

// Setup
function init() 
{
	clock = new THREE.Clock(); // Used in render() for controls.update()
	projector = new THREE.Projector(); // Used in bullet projection
	scene = new THREE.Scene(); // Holds all objects in the canvas
	//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0005); // color, density
	
	// Set up camera
	cam = new THREE.PerspectiveCamera(40, ASPECT_RATIO, 1, 10000); // FOV, aspect, near, far
	cam.position.y = 130;
	cam.position.x = 0;
	cam.position.z = -1125;
	cam.lookAt(new THREE.Vector3( 0, 84, 1125 ));
	scene.add(cam);
	
	// Camera moves with mouse, flies around with WASD/arrow keys
	controls = new THREE.FirstPersonControls(cam);
	controls.freeze = true;
	controls.movementSpeed = 600;
	controls.lookSpeed = .15;
	
	controls.lookVertical = true; // Temporary solution; play on flat surfaces only
	controls.noFly = true;
	
	// World objects
	setupScene();
	initPlayers();
	
	// Handle drawing as WebGL (faster than Canvas but less supported)
	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(WIDTH, HEIGHT);
	var spotLight = new THREE.SpotLight( 0xF7EFBE );
	spotLight.position.set( 0, 1000, 0 );

	spotLight.castShadow = true;

	spotLight.shadow.mapSize.width = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;
	spotLight.shadow.mapSize.height = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;

	spotLight.shadow.camera.near = 1;
	spotLight.shadow.camera.far = 10000;
	spotLight.shadow.camera.fov = 60;

	scene.add(spotLight);
	
	// Add the canvas to the document
	document.body.appendChild(renderer.domElement);
	
	// Track mouse position so we know where to shoot
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener('mouseup', onDocumentMouseUp, false);
	
	// Display HUD
	$('body').append('<div id="hud"><p>Health: <span id="health">100</span><br />Score: <span id="score">0</span></p></div>');
	$('body').append('<div class="health-bar" data-total="1000" data-value="1000"><div class="bar"><div class="hit"></div></div></div>');
	$('body').append('<div class="power-bar" data-total="1000" data-value="0"><div class="power"></div></div>');
	
	// Set up "hurt" flash
	$('body').append('<div id="hurt"></div>');
	$('#hurt').css({width: WIDTH, height: HEIGHT,});
}

// Helper function for browser frames
function animate() {
	if (runAnim) {	requestAnimationFrame(animate); }
	render();
}

// Update and display
function render() 
{
	var delta = clock.getDelta();
	var speed = delta * BULLET_SPEED;

	controls.update(delta); // Move camera
	updatePhysics( speed );

	renderer.autoClear = false;
	renderer.clear();
	renderer.render(backgroundScene, backgroundCamera)
	renderer.render(scene, cam); // Repaint
	time += delta;
}

// Set up the objects in the world
function setupScene() 
{
	// Initialize the floor
	var floorGeo = new THREE.CubeGeometry(mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE);
	floorGeo.computeVertexNormals();
	floorGeo.computeFaceNormals();
	
	var floor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({color: 0xEDCBA0}));
	scene.add(floor);

	loader.load( 'models/wind.ply', function ( geometry ) {
		geometry.computeVertexNormals();

		var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
		
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.y = 75;
		mesh.position.x = 100;
		mesh.position.z = -900;
		mesh.rotation.x = - Math.PI / 2;
		
		let angle = Math.atan2(wind.z,-wind.x);
		mesh.rotation.z = angle;
		mesh.rotation.z += (1.5708*2); 
		mesh.scale.multiplyScalar( .1 );
		mesh.castShadow = true;
		mesh.receiveShadow = true;

		scene.add( mesh );
	});

	loader.load( 'models/wind.ply', function ( geometry ) {
		geometry.computeVertexNormals();
		
		var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
		
		var mesh2 = new THREE.Mesh( geometry, material );
		mesh2.position.y = 75;
		mesh2.position.x = -100;
		mesh2.position.z = 900;
		mesh2.rotation.x = - Math.PI / 2;
		
		let angle = Math.atan2(wind.z,-wind.x);
		mesh2.rotation.z = angle;
		mesh2.rotation.z += (1.5708*2); 
		mesh2.scale.multiplyScalar( .1 );
		mesh2.castShadow = true;
		mesh2.receiveShadow = true;
		
		scene.add( mesh2 );
	});

	// Lighting
	var directionalLight1 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight1.position.set( .5, .9, .5);
	directionalLight1.castShadow = true;
	scene.add( directionalLight1 );

	var directionalLight2 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight2.position.set( -.5, .9, -.5);
	directionalLight2.castShadow = true;
	scene.add( directionalLight2 );

	// Background

	// Load the background texture
	var texture = new THREE.TextureLoader().load('images/Top-Header-Grass-Sky-Background-JPG.jpg');
	var backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: texture}));

	// The background (skybox) should have no effect on depth buffer.
	backgroundMesh.material.depthTest = false;
	backgroundMesh.material.depthWrite = false;

	// Create your background scene
	backgroundScene = new THREE.Scene();
	backgroundCamera = new THREE.Camera();

	// Add the background to the scene.
	backgroundScene.add(backgroundCamera);
	backgroundScene.add(backgroundMesh);
}

function initPlayers() 
{
	// Add player one's bow object to scene
	var bow1 = new THREE.Object3D();
	bow1.name = "bow1";		
	bow1.position.y = -25;
	bow1.position.x = 0;
	bow1.position.z = -36;
	scene.add(bow1);

	// Add player one's bow object to scene
	var bow2 = new THREE.Object3D();
	bow2.name = "bow2";		
	bow2.position.y = -25;
	bow2.position.x = 0;
	bow2.position.z = -36;
	scene.add(bow2);

	console.log(scene.children);

	// Load the PLY model for the bows and assign the meshes to their corresponding objects.
	loader.load( 'models/bow.ply', function ( geometry ) {
		geometry.computeVertexNormals();
		
		var material = new THREE.MeshStandardMaterial( { color: 0x7c440b, flatShading: true } );
		var mesh = new THREE.Mesh( geometry, material );
		mesh.rotateZ(1.5708);
		mesh.scale.multiplyScalar( .35 );

		let parent1 = scene.getObjectByName("bow1");
		if(parent1) {
			parent1.add(mesh);
		}		

		let parent2 = scene.getObjectByName("bow2");
		if(parent2) {
			parent2.add(mesh);
		}
	});

	// Add player one
	player1 = new Player(0xff0000, new THREE.Vector3(0, 84, -1125), new THREE.Euler(0, 0, 0));
	player1.leftHandDummy.add(scene.getObjectByName("bow1"));
	
	players.push(player1.torso);
	scene.add(player1.torsoDummy);

	// Add player two
	player2 = new Player(0x0000ff, new THREE.Vector3(0, 84, 1125), new THREE.Euler(0, 1.5708 * 2, 0));
	player2.leftHandDummy.add(scene.getObjectByName("bow2"));

	players.push(player2.torso);
	scene.add(player2.torsoDummy);
}

function distance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}

function getMapSector(v) {
	var x = Math.floor((v.x + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	var z = Math.floor((v.z + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	return {x: x, z: z};
}

function checkWallCollision(v) {
	var c = getMapSector(v);
	return map[c.x][c.z] > 0;
}

function onDocumentMouseDown(e) {

	// Reset the power and arrow speed.
	pow = .1;
	ARROWSPEED = 1;
	$('.power').css({width: 0+"%",});
	$('.power-bar').css({value: 0,});
	// Prevent infinite loop.
	if(mousedownID == -1) {
		mousedownID = setInterval(whileMouseDown, 100 /*execute every 100ms*/);
	}  
}

function whileMouseDown() {
	// While holding mouse down, increase arrow power.
	ARROWSPEED += 1;
	// TODO working on changing the velocity based on which player we are.
	if(wind.z > 0)
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/50, wind.z*ARROWSPEED/(2*Math.PI)) );
	else
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/50, wind.z*-ARROWSPEED/(2*Math.PI)) );

	// Grab CSS of the power bar.
	var value = $('.power-bar').data('value');
	var total = $('.power-bar').data('total');
	
	// Update the value based on power.
    var newValue = pow;
	pow += .01;
	var barWidth = (newValue / total) * 100;
  
	if(pow * 100 < 100) {
		var hitWidth = (pow) * 100 + "%";
	}
    else {
		var hitWidth = 100 + "%";
	}
    // Update the data of the CSS.
	$('.power').css({width: hitWidth,});
	$('.power-bar').css({value: newValue,});
}

function onDocumentMouseUp(e) {
	if(mousedownID != -1) 
	{  //Only stop if exists
	  clearInterval(mousedownID);
	  mousedownID = -1;
	}
  	
  	mouseCoords.set(
		 ( event.clientX / window.innerWidth ) * 2 - 1, // Set Mouse x-coordinates
		-( event.clientY / window.innerHeight ) * 2 + 1 // Set Mouse y-coordinates
	);
	
	raycaster.setFromCamera( mouseCoords, cam );
	
	// Creates a ball and throws it
	var ballMass = 1;
	var ballRadius = 2;
	var ball = new THREE.Mesh( new THREE.SphereBufferGeometry( ballRadius, 14, 10 ), ballMaterial );
				 
	ball.castShadow = true;
	ball.receiveShadow = true;

	var ballShape = new Ammo.btSphereShape( ballRadius );
	ballShape.setMargin( margin );
	
	pos.copy( raycaster.ray.direction );
	pos.add( raycaster.ray.origin );
	
	quat.set( 0, 0, 0, 1 );
	
	var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );
	pos.copy( raycaster.ray.direction );
	pos.multiplyScalar( 24 );
	
	ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
}


// Handle window resizing
$(window).resize(function() 
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	
	ASPECT_RATIO = WIDTH / HEIGHT;
	
	if (cam) {
		cam.aspect = ASPECT_RATIO;
		cam.updateProjectionMatrix();
	}

	if (renderer) {
		renderer.setSize(WIDTH, HEIGHT);
	}
	
	$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
});

// Stop moving around when the window is unfocused (keeps my sanity!)
$(window).focus(function() {
	if (controls) controls.freeze = false; 
});
$(window).blur(function() {
	if (controls) controls.freeze = true;
});
	
function removeDebris(object) {
	scene.remove( object );
	physicsWorld.removeRigidBody( object.userData.physicsBody );
}


function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) 
{
	if (pos) {
		object.position.copy( pos );
	} else {
		pos = object.position;
	}

	if (quat) {
		object.quaternion.copy( quat );
	} else {
		quat = object.quaternion;
	}
	
	var transform = new Ammo.btTransform();

	transform.setIdentity();
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
	
	var motionState = new Ammo.btDefaultMotionState( transform );
	var localInertia = new Ammo.btVector3( 0, 0, 0 );
	
	physicsShape.calculateLocalInertia( mass, localInertia );
	
	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
	var body = new Ammo.btRigidBody( rbInfo );
	
	body.setFriction( 0.5 );

	if ( vel ) {
		body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
	}
	
	if ( angVel ) {
		body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );
	}
	
	object.userData.physicsBody = body;
	object.userData.collided = false;
	scene.add( object );
	
	if ( mass > 0 ) {
		rigidBodies.push( object );
		body.setActivationState( 4 ); // Disable deactivation
	}

	physicsWorld.addRigidBody( body );
	
	return body;
}

function initPhysics() {
	// Physics configuration
	collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
	
	dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
	broadphase = new Ammo.btDbvtBroadphase();
	solver = new Ammo.btSequentialImpulseConstraintSolver();
	
	physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), -GRAVITY/50, wind.z/(2*Math.PI)) );
}

function updatePhysics( deltaTime ) 
{
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 );
	
	// Update rigid bodies
	for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
		var objThree = rigidBodies[ i ];
		var objPhys = objThree.userData.physicsBody;

		var ms = objPhys.getMotionState();
		
		if ( ms ) {
			ms.getWorldTransform( transformAux1 );
			
			var p = transformAux1.getOrigin();
			var q = transformAux1.getRotation();
			
			objThree.position.set(p.x(), p.y(), p.z());
			
			objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			objThree.userData.collided = false;
		}
	}

	for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {
		
		var contactManifold = dispatcher.getManifoldByIndexInternal( i );
		
		var rb0 = contactManifold.getBody0();
		var rb1 = contactManifold.getBody1();
		
		var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
		var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;
		
		if ( ! threeObject0 && ! threeObject1 ) 
		{
			continue;
		}
		
		var userData0 = threeObject0 ? threeObject0.userData : null;
		var userData1 = threeObject1 ? threeObject1.userData : null;
		
		var breakable0 = userData0 ? userData0.breakable : false;
		var breakable1 = userData1 ? userData1.breakable : false;
		
		var collided0 = userData0 ? userData0.collided : false;
		var collided1 = userData1 ? userData1.collided : false;
		
		if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
			continue;
		}

		var contact = false;
		var maxImpulse = 0;
		
		for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {
			var contactPoint = contactManifold.getContactPoint( j );
			
			if ( contactPoint.getDistance() < 0 ) {
				contact = true;
				
				var impulse = contactPoint.getAppliedImpulse();
				
				if ( impulse > maxImpulse ) {
					maxImpulse = impulse;
					
					var pos = contactPoint.get_m_positionWorldOnB();
					var normal = contactPoint.get_m_normalWorldOnB();
					
					impactPoint.set( pos.x(), pos.y(), pos.z() );
					impactNormal.set( normal.x(), normal.y(), normal.z() );
				}

				break;
			}
		}

		// If no point has contact, abort
		if (!contact) continue;

		// Subdivision
		var fractureImpulse = 250;
		
		if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) {
				createDebrisFromBreakableObject( debris[ j ] );
			}

			objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
			
			userData0.collided = true;
		}
		
		if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			
			objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
			
			userData1.collided = true;
		}
	}

	for ( var i = 0; i < numObjectsToRemove; i++ ) {
		removeDebris( objectsToRemove[ i ] );
	}

	numObjectsToRemove = 0;
}

function initWind() {
	wind = new THREE.Vector3(getRandomArbitrary(-2*Math.PI, 2*Math.PI), 1, getRandomArbitrary(-2*Math.PI, 2*Math.PI));
	//console.log(wind.x,wind.y,wind.z);
}

function createRandomColor() {
	return Math.floor( Math.random() * ( 1 << 24 ) );
}

function createMaterial( color ) {
	color = color || createRandomColor();
	return new THREE.MeshPhongMaterial( { color: color } );
}

function getRandomArbitrary(min, max) {
	return Math.random() * (max - min) + min;
}
</script>
</html>