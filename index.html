<!DOCTYPE html>
<html>
<head>
	<title>WebGL Multiplayer Target</title>

	<link rel="stylesheet" type="text/css" href="index_style.css">
	
	<script src="jquery-1.7.2.min.js"></script>

	<script src="three.js-master/build/three.js"></script>

	<script src="three.js-master/examples/js/renderers/Projector.js"></script>
	<script src="three.js-master/examples/js/libs/ammo.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script src="three.js-master/examples/js/WebGL.js"></script>
	<script src="three.js-master/examples/js/ConvexObjectBreaker.js"></script>
	<script src="three.js-master/examples/js/QuickHull.js"></script>
	<script src="three.js-master/examples/js/geometries/ConvexGeometry.js"></script>
	<script src="three.js-master/examples/js/loaders/STLLoader.js"></script>
	<script src="three.js-master/examples/js/loaders/PLYLoader.js"></script>
	<script src="three.js-master/examples/js/geometries/hilbert3D.js"></script>
	<script src='three.js-master/examples/js/lines/LineSegmentsGeometry.js'></script>
	<script src='three.js-master/examples/js/lines/LineGeometry.js'></script>
	<script src='three.js-master/examples/js/lines/WireframeGeometry2.js'></script>

	<script src='three.js-master/examples/js/lines/LineMaterial.js'></script>

	<script src='three.js-master/examples/js/lines/LineSegments2.js'></script>
	<script src='three.js-master/examples/js/lines/Line2.js'></script>
	<script src='three.js-master/examples/js/lines/Wireframe.js'></script>
	
	<script src="three.js-master/src/loaders/TextureLoader.js"></script>

	<script src="Three.FirstPersonControls.js"></script>

	<script src="Player.js"></script>
</head>

<body>
</body>

<script>

// Initalize the map where '1' represents a "wall".
var map = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]];
var mapW = map.length;
var mapH = map[0].length;

// Semi-constants
var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;
var ASPECT_RATIO = WIDTH / HEIGHT;
var UNIT_SIZE = 250;
var BULLET_SPEED = 500;
var PROJECTILE_DAMAGE = 20;
var ARROW_SPEED = 1;
var GRAVITY = 9.81;

// Global vars
var scene, cam, backgroundScene, backgroundCamera, renderer, controls, clock, projector, model, skin;
var runAnim = true
var mouseCoords = new THREE.Vector2();
var container, stats;
var textureLoader;
var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
var loader = new THREE.STLLoader();
var mousedownID = -1;
var pow = .1;
var testArrow;

// Holds the Player objects for our game.
var players = [];

var player1;
var player2;

// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;
var wind;

var rigidBodies = [];
var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
var time = 0;
var objectsToRemove = [];
for ( var i = 0; i < 500; i++ ) 
{
	objectsToRemove[ i ] = null;
}
var numObjectsToRemove = 0;
var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();
var hBar = $('.health-bar');
var bar = hBar.find('.bar');
var hit = hBar.find('.hit');
var pBar = $('.power-bar'),
power = pBar.find('.power');

// Initialize and run on document ready
$(document).ready(function() 
{
	$('body').append('<div id="intro">Click to start</div>');
	$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) 
	{
		e.preventDefault();
		$(this).fadeOut();
		 init();
		 initWind();
		 initPhysics();
		//setInterval(drawWind, 1000);
		animate();
	});
});

// Setup
function init() 
{
	clock = new THREE.Clock(); // Used in render() for controls.update()
	projector = new THREE.Projector(); // Used in bullet projection
	scene = new THREE.Scene(); // Holds all objects in the canvas
	//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0005); // color, density
	
	// Set up camera
	cam = new THREE.PerspectiveCamera(60, ASPECT_RATIO, 1, 10000); // FOV, aspect, near, far
	cam.position.y = 130;
	cam.position.x = 0;
	cam.position.z = -1125;
	scene.add(cam);
	
	// Camera moves with mouse, flies around with WASD/arrow keys
	controls = new THREE.FirstPersonControls(cam);
	controls.movementSpeed = 600;
	controls.lookSpeed = .15;
	
	controls.lookVertical = true; // Temporary solution; play on flat surfaces only
	controls.noFly = true;
	
	// World objects
	setupScene();
	initTargets();
	
	// Handle drawing as WebGL (faster than Canvas but less supported)
	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(WIDTH, HEIGHT);
	var spotLight = new THREE.SpotLight( 0xF7EFBE );
	spotLight.position.set( 0, 1000, 0 );

	spotLight.castShadow = true;

	spotLight.shadow.mapSize.width = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;
	spotLight.shadow.mapSize.height = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;

	spotLight.shadow.camera.near = 1;
	spotLight.shadow.camera.far = 10000;
	spotLight.shadow.camera.fov = 60;

	scene.add(spotLight);
	
	// Add the canvas to the document
	document.body.appendChild(renderer.domElement);
	
	// Track mouse position so we know where to shoot
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener('mouseup', onDocumentMouseUp, false);
	document.addEventListener('mousemove', onDocumentMouseMove, false);
	
	// Display HUD
	$('body').append('<div id="hud"><p>Health: <span id="health">100</span><br />Score: <span id="score">0</span></p></div>');
	$('body').append('<div class="health-bar" data-total="1000" data-value="1000"><div class="bar"><div class="hit"></div></div></div>');
	$('body').append('<div class="power-bar" data-total="1000" data-value="0"><div class="power"></div></div>');
	
	// Set up "hurt" flash
	$('body').append('<div id="hurt"></div>');
	$('#hurt').css({width: WIDTH, height: HEIGHT,});
}

// Helper function for browser frames
function animate() {
	if (runAnim) {	requestAnimationFrame(animate); }
	render();
}

// Update and display
function render() 
{
	var delta = clock.getDelta();
	var speed = delta * BULLET_SPEED;

	controls.update(delta); // Move camera
	updatePhysics( speed );
for (let index = 0; index < rigidBodies.length; index++) 
{
	let thisArrow = rigidBodies[index];
	if(thisArrow.position.x > 2000 || thisArrow.position.x < -2000 || thisArrow.position.z > 2000 || thisArrow.position.z < -2000)
	{
		scene.remove(thisArrow);
	}
	

}
	let arrowDir = scene.getObjectByName("arrowDir");
	if(arrowDir)
	{
		//console.log(arrowDir.direction);
		//arrowDir.position.set(raycaster.ray.origin);
		raycaster.setFromCamera( mouseCoords, cam );
		arrowDir.setDirection(raycaster.ray.direction);
	}
	
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(backgroundScene, backgroundCamera)
	renderer.render(scene, cam); // Repaint
	time += delta;
}

// Set up the objects in the world
function setupScene() 
{
	// Initialize the floor
	var floorGeo = new THREE.CubeGeometry(mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE);
	floorGeo.computeVertexNormals();
	floorGeo.computeFaceNormals();
	
	var floor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({color: 0xEDCBA0}));
	scene.add(floor);

	var loader = new THREE.PLYLoader();
				loader.load( 'models/wind.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.y = 75;
					mesh.position.x = 100;
					mesh.position.z = -900;
					mesh.rotation.x = - Math.PI / 2;
					let angle = Math.atan2(wind.z,-wind.x);
					mesh.rotation.z = angle;
					mesh.rotation.z += (1.5708*2); 
					mesh.scale.multiplyScalar( .1 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );
				} );

	var loader = new THREE.PLYLoader();
				loader.load( 'models/wind.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
					var mesh2 = new THREE.Mesh( geometry, material );
					mesh2.position.y = 75;
					mesh2.position.x = -100;
					mesh2.position.z = 900;
					mesh2.rotation.x = - Math.PI / 2;
					let angle = Math.atan2(wind.z,-wind.x);
					mesh2.rotation.z = angle;
					mesh2.rotation.z += (1.5708*2); 
					mesh2.scale.multiplyScalar( .1 );
					mesh2.castShadow = true;
					mesh2.receiveShadow = true;
					scene.add( mesh2 );
				} );

	var arrowMark = new THREE.ArrowHelper(
		new THREE.Vector3(0,0,1), new THREE.Vector3(0,130,-1125), 1000, 0x884400);
	arrowMark.name = "arrowDir";
	scene.add(arrowMark);
	console.log("added arrow");
						
	// Lighting
	var directionalLight1 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight1.position.set( .5, .9, .5);
	directionalLight1.castShadow = true;
	scene.add( directionalLight1 );

	var directionalLight2 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight2.position.set( -.5, .9, -.5);
	directionalLight2.castShadow = true;
	scene.add( directionalLight2 );

	// Background

	// Load the background texture
	var texture = new THREE.TextureLoader().load('images/Top-Header-Grass-Sky-Background-JPG.jpg');
	var backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: texture}));

	// The background (skybox) should have no effect on depth buffer.
	backgroundMesh.material.depthTest = false;
	backgroundMesh.material.depthWrite = false;

	// Create your background scene
	backgroundScene = new THREE.Scene();
	backgroundCamera = new THREE.Camera();

	// Add the background to the scene.
	backgroundScene.add(backgroundCamera);
	backgroundScene.add(backgroundMesh);
}

function initTargets() 
{
	// Add player one
	player1 = new Player(0xff0000, new THREE.Vector3(0, 168/2, -1125), new THREE.Euler(0, 0, 0));

	players.push(player1.torso);
	scene.add(player1.torsoDummy);

	// Add player two
	player2 = new Player(0x0000ff, new THREE.Vector3(0, 168/2, 1125), new THREE.Euler(0, 1.5708 * 2, 0));

	players.push(player2.torso);
	scene.add(player2.torsoDummy);
}

function distance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}

function getMapSector(v) {
	var x = Math.floor((v.x + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	var z = Math.floor((v.z + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	return {x: x, z: z};
}

function checkWallCollision(v) {
	var c = getMapSector(v);
	return map[c.x][c.z] > 0;
}

function onDocumentMouseDown(e) {
	// Reset the power and arrow speed.
	//console.log(raycaster.ray.origin);
	pow = .1;
	ARROWSPEED = 1;
	$('.power').css({width: 0+"%",});
	$('.power-bar').css({value: 0,});
	// Prevent infinite loop.
	if(mousedownID == -1) {
		mousedownID = setInterval(whileMouseDown, 100 /*execute every 100ms*/);
	}  
}

function whileMouseDown() {
	// var lineMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
	// var lineGeo = new THREE.Geometry();
	// lineGeo.vertices.push(new THREE.Vector3( -10, 0, 0) );
	// lineGeo.vertices.push(new THREE.Vector3( 0, 10, 0) );
	// //lineGeo.vertices.push(new THREE.Vector3( 10, 0, 0) );
	// var line = new THREE.Line( lineGeo, lineMaterial );
	// scene.add( line );
	
	
	// While holding mouse down, increase arrow power.
	ARROWSPEED += 1;
	// TODO working on changing the velocity based on which player we are.
	if(wind.z > 0)
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/50, wind.z*ARROWSPEED/(2*Math.PI)) );
	else
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/50, wind.z*-ARROWSPEED/(2*Math.PI)) );

	// Grab CSS of the power bar.
	var value = $('.power-bar').data('value');
	var total = $('.power-bar').data('total');
	
	// Update the value based on power.
    var newValue = pow;
	pow += .02;
	var barWidth = (newValue / total) * 100;
	if(pow * 100 < 100) {
		var hitWidth = (pow) * 100 + "%";
	}
    else {
		var hitWidth = 100 + "%";
	}
    // Update the data of the CSS.
	$('.power').css({width: hitWidth,});
	$('.power-bar').css({value: newValue,});
}
function onDocumentMouseMove(e)
{
	mouseCoords.set(
		 ( event.clientX / window.innerWidth ) * 2 - 1, // Set Mouse x-coordinates
		-( event.clientY / window.innerHeight ) * 2 + 1 // Set Mouse y-coordinates
	);
}
function onDocumentMouseUp(e) {
	if(mousedownID != -1) 
	{  //Only stop if exists
	  clearInterval(mousedownID);
	  mousedownID = -1;
	}
  	
  	mouseCoords.set(
		 ( event.clientX / window.innerWidth ) * 2 - 1, // Set Mouse x-coordinates
		-( event.clientY / window.innerHeight ) * 2 + 1 // Set Mouse y-coordinates
	);
	
	raycaster.setFromCamera( mouseCoords, cam );
	
	// Creates a ball and throws it
	var ballMass = 1;
	var ballRadius = 2;
	var loader = new THREE.PLYLoader();
	loader.load( 'models/Arrow.ply', function ( geometry ) {
		geometry.computeVertexNormals();
		var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
		var mesh3 = new THREE.Mesh( geometry, material );
		mesh3.position.y = 100;
		mesh3.position.x = -100;
		mesh3.position.z = 900;
		//mesh3.rotation.x = - Math.PI / 2;
		//let angle = Math.atan2(wind.z,-wind.x);
		//mesh3.rotation.z = angle;
		mesh3.rotation.z += (1.5708); 
		mesh3.scale.multiplyScalar( 10.0 );
		mesh3.castShadow = true;
		mesh3.receiveShadow = true;
		mesh3.castShadow = true;
		mesh3.receiveShadow = true;

		var ballShape = new Ammo.btSphereShape( ballRadius );
		ballShape.setMargin( margin );
		
		pos.copy( raycaster.ray.direction );
		pos.add( raycaster.ray.origin );
		
		quat.set( 0, 0, 0, 1 );
		
		var ballBody = createRigidBody( mesh3, ballShape, ballMass, pos, quat, new THREE.Vector3(wind.x,0.0,wind.z) );
		pos.copy( raycaster.ray.direction );
		pos.multiplyScalar( 24 );
		
		ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	
	});
}


// Handle window resizing
$(window).resize(function() 
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	
	ASPECT_RATIO = WIDTH / HEIGHT;
	
	if (cam) {
		cam.aspect = ASPECT_RATIO;
		cam.updateProjectionMatrix();
	}

	if (renderer) {
		renderer.setSize(WIDTH, HEIGHT);
	}
	
	$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
});

// Stop moving around when the window is unfocused (keeps my sanity!)
$(window).focus(function() {
	if (controls) controls.freeze = false; 
});
$(window).blur(function() {
	if (controls) controls.freeze = true;
});
	
function removeDebris(object) {
	scene.remove( object );
	physicsWorld.removeRigidBody( object.userData.physicsBody );
}


function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) 
{
	if (pos) {
		object.position.copy( pos );
	} else {
		pos = object.position;
	}

	if (quat) {
		object.quaternion.copy( quat );
	} else {
		quat = object.quaternion;
	}
	
	var transform = new Ammo.btTransform();

	transform.setIdentity();
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
	
	var motionState = new Ammo.btDefaultMotionState( transform );
	var localInertia = new Ammo.btVector3( 0, 0, 0 );
	
	physicsShape.calculateLocalInertia( mass, localInertia );
	
	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
	var body = new Ammo.btRigidBody( rbInfo );
	
	body.setFriction( 0.5 );

	if ( vel ) {
		
		body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
		
	}
	
	if ( angVel ) {
		body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );
	}
	
	object.userData.physicsBody = body;
	object.userData.collided = false;
	scene.add( object );
	
	if ( mass > 0 ) {
		rigidBodies.push( object );
		body.setActivationState( 4 ); // Disable deactivation
	}
	
	//https://stackoverflow.com/questions/18370701/how-to-draw-the-trajectory-of-a-mesh-with-threejs
	physicsWorld.addRigidBody( body );
	// var arrowMark = new THREE.ArrowHelper(
	// 	raycaster.ray.direction, raycaster.ray.origin, 100, 0x884400);

	// // matLine = new THREE.LineMaterial( {
	// // 				color: 0xffffff,
	// // 				linewidth: 50, // in pixels
	// // 				vertexColors: THREE.VertexColors,
	// // 				//resolution:  // to be set by renderer, eventually
	// // 				dashed: false
	// // 			} );
	// //arrowMark.position.set(0,300,0);
	// console.log(arrowMark.line.material);
	// // Update arrow
	// //var pvel = body.getLinearVelocity();
	// //console.log(pvel);
	
	// let num = vel.normalize.x;
	// //arrowMark.setDirection(vel.normalize);
	// console.log(mouseCoords);
	// //arrowMark.setLength(1000);
	// scene.add(arrowMark);
	// console.log("added arrow");
	return body;
}

function initPhysics() {
	// Physics configuration
	collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
	
	dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
	broadphase = new Ammo.btDbvtBroadphase();
	solver = new Ammo.btSequentialImpulseConstraintSolver();
	
	physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
	physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), -GRAVITY/50, wind.z/(2*Math.PI)) );
}

function updatePhysics( deltaTime ) 
{
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 );
	
	// Update rigid bodies
	for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
		var objThree = rigidBodies[ i ];
		var objPhys = objThree.userData.physicsBody;
		
		var ms = objPhys.getMotionState();
		
		if ( ms ) {
			ms.getWorldTransform( transformAux1 );
			
			var p = transformAux1.getOrigin();
			var q = transformAux1.getRotation();
			
			objThree.position.set(p.x(), p.y(), p.z());
			
			//objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			objThree.rotation.y = (4.7124);
			objThree.userData.collided = false;
		}
	}

	for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {
		
		var contactManifold = dispatcher.getManifoldByIndexInternal( i );
		
		var rb0 = contactManifold.getBody0();
		var rb1 = contactManifold.getBody1();
		
		var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
		var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;
		
		if ( ! threeObject0 && ! threeObject1 ) 
		{
			continue;
		}
		
		var userData0 = threeObject0 ? threeObject0.userData : null;
		var userData1 = threeObject1 ? threeObject1.userData : null;
		
		var breakable0 = userData0 ? userData0.breakable : false;
		var breakable1 = userData1 ? userData1.breakable : false;
		
		var collided0 = userData0 ? userData0.collided : false;
		var collided1 = userData1 ? userData1.collided : false;
		
		if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
			continue;
		}

		var contact = false;
		var maxImpulse = 0;
		
		for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {
			var contactPoint = contactManifold.getContactPoint( j );
			
			if ( contactPoint.getDistance() < 0 ) {
				contact = true;
				
				var impulse = contactPoint.getAppliedImpulse();
				
				if ( impulse > maxImpulse ) {
					maxImpulse = impulse;
					
					var pos = contactPoint.get_m_positionWorldOnB();
					var normal = contactPoint.get_m_normalWorldOnB();
					
					impactPoint.set( pos.x(), pos.y(), pos.z() );
					impactNormal.set( normal.x(), normal.y(), normal.z() );
				}

				break;
			}
		}

		// If no point has contact, abort
		if (!contact) continue;

		// Subdivision
		var fractureImpulse = 250;
		
		if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) {
				createDebrisFromBreakableObject( debris[ j ] );
			}

			objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
			
			userData0.collided = true;
		}
		
		if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			
			objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
			
			userData1.collided = true;
		}
	}

	for ( var i = 0; i < numObjectsToRemove; i++ ) {
		removeDebris( objectsToRemove[ i ] );
	}

	numObjectsToRemove = 0;
}

function initWind() {
	wind = new THREE.Vector3(getRandomArbitrary(-2*Math.PI, 2*Math.PI), 1, getRandomArbitrary(-2*Math.PI, 2*Math.PI));
	//console.log(wind.x,wind.y,wind.z);
}

function createRandomColor() {
	return Math.floor( Math.random() * ( 1 << 24 ) );
}

function createMaterial( color ) {
	color = color || createRandomColor();
	return new THREE.MeshPhongMaterial( { color: color } );
}

function getRandomArbitrary(min, max) {
	return Math.random() * (max - min) + min;
}
</script>
</html>