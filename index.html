<!DOCTYPE html>
<html>
<head>
  <title>WebGL Multiplayer Target</title>
  <style>
    body {
      background-image: url('/Project/images/Top-Header-Grass-Sky-Background-JPG.jpg');
      background-size:100% 100%;
      cursor: crosshair;
      font-family: Georgia, Helvetica, sans-serif;
      font-weight: bold;
      margin: 0;
      overflow: hidden;
      padding: 0;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    #hud {
      bottom: 10px;
      position: absolute;
      right: 10px;
      z-index: 100;
    }
    #credits {
      font-size: 12px;
      position: absolute;
      text-align: center;
      top: 10px;
      width: 100%;
      z-index: 100;
    }
    p {
      background-color: #EEEEEE;
      border: 1px solid black;
      display: inline-block;
      margin: 0;
      padding: 5px;
    }
    #radar {
      background-color: #EEEEEE;
      border: 1px solid black;
      bottom: 10px;
      left: 10px;
      position: absolute;
      z-index: 100;
    }
    #intro {
      background-color: #000000;
      color: #FFFFFF;
      cursor: pointer;
      font-size: 32px;
      opacity: 0.7;
      padding: 120px;
      text-align: center;
      z-index: 1001;
    }
    #hurt {
      background-color: red;
      display: none;
      left: 0;
      opacity: 0.15;
      pointer-events: none;
      position: absolute;
      top: 0;
      z-index: 1002;
    }
  </style>
  <script src="jquery-1.7.2.min.js"></script>
  <script src="three.js-master/build/three.js"></script>
  <script src="Three.FirstPersonControls.js"></script>
  <script src="three.js-master/examples/js/renderers/Projector.js"></script>
  <script src="main.js"></script>
  <script src="three.js-master/examples/js/libs/ammo.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script src="three.js-master/examples/js/WebGL.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/ConvexObjectBreaker.js"></script>
	<script src="three.js-master/examples/js/QuickHull.js"></script>
  <script src="three.js-master/examples/js/geometries/ConvexGeometry.js"></script>
  <script src="three.js-master/examples/js/loaders/STLLoader.js"></script>
</head>
<body>
</body>
<script>
var map = [ // 1  0  3  4  5  6  7  8  9
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,], // 0
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 1
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 0
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 3
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 4
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 5
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 6
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 7
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 8
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,], // 9
           ], mapW = map.length, mapH = map[0].length;

// Semi-constants
var WIDTH = window.innerWidth,
	HEIGHT = window.innerHeight,
	ASPECT = WIDTH / HEIGHT,
	UNITSIZE = 250,
	WALLHEIGHT = UNITSIZE / 3,
	MOVESPEED = 100,
	LOOKSPEED = 0.075,
	BULLETMOVESPEED = MOVESPEED * 5,
	NUMTARGETS = 5,
	PROJECTILEDAMAGE = 20;
// Global vars
var scene, cam, backgroundScene, backgroundCamera, renderer, controls, clock, projector, model, skin;
var runAnim = true, kills = 0, health = 100;
var healthCube, lastHealthPickup = 0;
var gravityConstant = 9.8;
var mouseCoords = new THREE.Vector2();
var container, stats;
var textureLoader;
var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
var loader = new THREE.STLLoader();
// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;
//var convexBreaker = new THREE.ConvexObjectBreaker();
var rigidBodies = [];
var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
var time = 0;
var objectsToRemove = [];
for ( var i = 0; i < 500; i++ ) 
{
	objectsToRemove[ i ] = null;
}
var numObjectsToRemove = 0;
var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Initialize and run on document ready
$(document).ready(function() 
{
	$('body').append('<div id="intro">Click to start</div>');
	$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) 
	{
		e.preventDefault();
		$(this).fadeOut();
  	    init();
  	    initPhysics();
		animate();
	});
});

// Setup
function init() 
{
	clock = new THREE.Clock(); // Used in render() for controls.update()
	projector = new THREE.Projector(); // Used in bullet projection
	scene = new THREE.Scene(); // Holds all objects in the canvas
	//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0005); // color, density
	
	// Set up camera
	cam = new THREE.PerspectiveCamera(60, ASPECT, 1, 10000); // FOV, aspect, near, far
	cam.position.y = UNITSIZE * .2;
	cam.position.x = -1000;
	cam.position.z = -1000;
	scene.add(cam);
	
	// Camera moves with mouse, flies around with WASD/arrow keys
	controls = new THREE.FirstPersonControls(cam);
	controls.movementSpeed = 600;
	controls.lookSpeed = .15;
	
	controls.lookVertical = true; // Temporary solution; play on flat surfaces only
	controls.noFly = true;

	// World objects
	setupScene();
	initTargets();
	
	// Handle drawing as WebGL (faster than Canvas but less supported)
	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(WIDTH, HEIGHT);
	var spotLight = new THREE.SpotLight( 0xF7EFBE );
	spotLight.position.set( 0, 1000, 0 );

	spotLight.castShadow = true;

	spotLight.shadow.mapSize.width = mapW * UNITSIZE, 10, mapW * UNITSIZE;
	spotLight.shadow.mapSize.height = mapW * UNITSIZE, 10, mapW * UNITSIZE;

	spotLight.shadow.camera.near = 1;
	spotLight.shadow.camera.far = 10000;
	spotLight.shadow.camera.fov = 60;

	scene.add( spotLight );
	
	// Add the canvas to the document
	document.body.appendChild(renderer.domElement);
	
	// Track mouse position so we know where to shoot
  	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	
	// Display HUD
	//$('body').append('<canvas id="radar" width="200" height="200"></canvas>');
	$('body').append('<div id="hud"><p>Health: <span id="health">100</span><br />Score: <span id="score">0</span></p></div>');
	//$('body').append('<div id="credits"><p>Created by <a href="http://www.isaacsukin.com/">Isaac Sukin</a> using <a href="http://mrdoob.github.com/three.js/">Three.js</a><br />WASD to move, mouse to look, click to shoot</p></div>');
	
	// Set up "hurt" flash
	$('body').append('<div id="hurt"></div>');
	$('#hurt').css({width: WIDTH, height: HEIGHT,});
}

// Helper function for browser frames
function animate() 
{
	if (runAnim) 
	{
		requestAnimationFrame(animate);
	}
	render();
}

// Update and display
function render() 
{
  	var delta = clock.getDelta(), speed = delta * BULLETMOVESPEED;
	controls.update(delta); // Move camera
	updatePhysics( speed );
	
	// Update bullets. Walk backwards through the list so we can remove items.
	for (var i = bullets.length-1; i >= 0; i--) 
	{
		var b = bullets[i], p = b.position, d = b.ray.direction;
		if (checkWallCollision(p)) 
		{
			bullets.splice(i, 1);
			scene.remove(b);
			continue;
		}
		// Collide with AI
		var hit = false;
		for (var j = targets.length-1; j >= 0; j--) 
		{
			var a = targets[j];
			var v = a.geometry.vertices[0];
			var c = a.position;
			var x = Math.abs(v.x), z = Math.abs(v.z);
			//console.log(Math.round(p.x), Math.round(p.z), c.x, c.z, x, z);
			if (p.x < c.x + x && p.x > c.x - x &&
					p.z < c.z + z && p.z > c.z - z &&
					b.owner != a) 
					{
				bullets.splice(i, 1);
				scene.remove(b);
				a.health -= PROJECTILEDAMAGE;
				var color = a.material.color, percent = a.health / 100;
				a.material.color.setRGB(
						percent * color.r,
						percent * color.g,
						percent * color.b
				);
				hit = true;
				break;
			}
		}
		b.translateX(speed * d.x);
		b.translateZ(speed * d.z);
  	}
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(backgroundScene, backgroundCamera)
	renderer.render(scene, cam); // Repaint
	time += delta;
}

// Set up the objects in the world
function setupScene() 
{
	var UNITSIZE = 250, units = mapW;
	var floorGeo = new THREE.CubeGeometry(units * UNITSIZE, 10, units * UNITSIZE);
	floorGeo.computeVertexNormals();
	floorGeo.computeFaceNormals();
	//Geometry: floor
	var floor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({color: 0xEDCBA0}));
	floor.receiveShadow = true;
	scene.add(floor);
	

	// Lighting
	var directionalLight1 = new THREE.DirectionalLight(0xF7EFBE, .5);
	 directionalLight1.position.set( .5, .9, .5);
	 directionalLight1.castShadow = true;
	 scene.add( directionalLight1 );
	 var directionalLight2 = new THREE.DirectionalLight(0xF7EFBE, .5);
	 directionalLight2.position.set( -.5, .9, -.5);
	 directionalLight2.castShadow = true;
	 scene.add( directionalLight2 );
	
	// Load the background texture
	var texture = new THREE.ImageUtils.loadTexture('images/Top-Header-Grass-Sky-Background-JPG.jpg');
	var backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: texture}));

	backgroundMesh .material.depthTest = false;
	backgroundMesh .material.depthWrite = false;

	// Create your background scene
	backgroundScene = new THREE.Scene();
	backgroundCamera = new THREE.Camera();
	backgroundScene .add(backgroundCamera);
	backgroundScene .add(backgroundMesh);
}

var targets = [];
var player1;
var player2;
var headGeo = new THREE.CubeGeometry(16, 16, 16);
var torsoGeo = new THREE.CubeGeometry(40, 25, 20);
var lowerTorsoGeo = new THREE.CubeGeometry(34, 15, 18);
var shoulderGeo = new THREE.CubeGeometry(12, 20, 8);
var armGeo = new THREE.CubeGeometry(10, 20, 6);
var handGeo = new THREE.CubeGeometry(4, 12, 12);
var waistGeo = new THREE.CubeGeometry(14, 12, 18);
var thighGeo = new THREE.CubeGeometry(12, 26, 12);
var calfGeo = new THREE.CubeGeometry(10, 26, 10);
var footGeo = new THREE.CubeGeometry(12, 4, 20);

function initTargets() 
{
	for (var i = 0; i < 1; i++) 
	{
		addAI();
	}
}

function addAI() 
{
	var c = getMapSector(cam.position);
	var player1Material = new THREE.MeshPhongMaterial({color: 0xff0000});
	var player2Material = new THREE.MeshPhongMaterial({color: 0x0000ff});
	var material = player1Material;
	for(let i = 1; i < 3 ; i++)
	{

	if(i == 2)
	{
		material = player2Material;
	}
	var torsoDummy = new THREE.Object3D();

	var torso = new THREE.Mesh(torsoGeo, material);
	torso.position.set(0,8,0);
	torsoDummy.add(torso);

	var lowerTorso = new THREE.Mesh(lowerTorsoGeo, material);
	lowerTorso.position.set(0,-12.5,0);
	torsoDummy.add(lowerTorso);

	var leftShoulderDummy = new THREE.Object3D();
	leftShoulderDummy.position.set(26,16,0);
	torsoDummy.add(leftShoulderDummy);
	var leftShoulder = new THREE.Mesh(shoulderGeo, material);
	leftShoulder.position.set(0,-8,0);
	leftShoulderDummy.add(leftShoulder);

	var rightShoulderDummy = new THREE.Object3D();
	rightShoulderDummy.position.set(-26,16,0);
	torsoDummy.add(rightShoulderDummy);
	var rightShoulder = new THREE.Mesh(shoulderGeo, material);
	rightShoulder.position.set(0,-8,0);
	rightShoulderDummy.add(rightShoulder);

	var leftArmDummy = new THREE.Object3D();
	leftArmDummy.position.set(0,-18,4);
	leftShoulderDummy.add(leftArmDummy);
	var leftArm =  new THREE.Mesh(armGeo, material);
	leftArm.position.set(0,-10,-4);
	leftArmDummy.add(leftArm);


	var rightArmDummy = new THREE.Object3D();
	rightArmDummy.position.set(0,-18,4);
	rightShoulderDummy.add(rightArmDummy);
	var rightArm =  new THREE.Mesh(armGeo, material);
	rightArm.position.set(0,-10,-4);
	rightArmDummy.add(rightArm);

	var leftHand = new THREE.Mesh(handGeo, material);
	leftHand.position.set(0, -26, -4.0);
	leftArmDummy.add(leftHand);

	var rightHand = new THREE.Mesh(handGeo, material);
	rightHand.position.set(0, -26, -4.0);
	rightArmDummy.add(rightHand);

	var head = new THREE.Mesh(headGeo, material);
	head.position.set(0, 28, 0);
	torsoDummy.add(head);

	var lowerTorsoDummy = new THREE.Object3D();
	lowerTorsoDummy.position.set(0,-10,0);
	torsoDummy.add(lowerTorsoDummy);

	var lowerTorso = new THREE.Mesh(lowerTorsoGeo, material);
	//lowerTorso.position.set(0,-10,0);
	lowerTorsoDummy.add(lowerTorso);

	var waistDummy = new THREE.Object3D();
	waistDummy.position.set(0,-26,0);
	torsoDummy.add(waistDummy);
	var waist =  new THREE.Mesh(waistGeo, material);
	waistDummy.add(waist);

	var leftThighDummy = new THREE.Object3D();
	leftThighDummy.position.set(13,-20,0);
	waistDummy.add(leftThighDummy);
	var leftThigh = new THREE.Mesh(thighGeo, material);
	leftThigh.position.set(0,13,0);
	leftThighDummy.add(leftThigh);

	var rightThighDummy = new THREE.Object3D();
	rightThighDummy.position.set(-13,-20,0);
	waistDummy.add(rightThighDummy);
	var rightThigh = new THREE.Mesh(thighGeo, material);
	rightThigh.position.set(0,13,0);
	rightThighDummy.add(rightThigh);

	var rightCalfDummy = new THREE.Object3D();
	rightCalfDummy.position.set(0,-26,0);
	rightThighDummy.add(rightCalfDummy);
	var rightCalf = new THREE.Mesh(calfGeo, material);
	rightCalf.position.set(0,13,0);
	rightCalfDummy.add(rightCalf);

	var leftCalfDummy = new THREE.Object3D();
	leftCalfDummy.position.set(0,-26,0);
	leftThighDummy.add(leftCalfDummy);
	var leftCalf = new THREE.Mesh(calfGeo, material);
	leftCalf.position.set(0,13,0);
	leftCalfDummy.add(leftCalf);

	var leftFoot = new THREE.Mesh(footGeo, material);
	leftFoot.position.set(0, -2, 4);
	leftCalfDummy.add(leftFoot);

	var rightFoot = new THREE.Mesh(footGeo, material);
	rightFoot.position.set(0, -2, 4);
	rightCalfDummy.add(rightFoot);
	if(i == 2)
	{
		torsoDummy.position.set(-1000, 168/2, -1000);
		torsoDummy.rotation.y += 7.1;
		player2 = torsoDummy;
	}
	else
	{
		torsoDummy.position.set(1000, 168/2, 1000);
		torsoDummy.rotation.y -= 15;
		player1 = torsoDummy;
	}
	torso.castShadow = true;
	torso.receiveShadow = true;
	lowerTorso.castShadow = true;
	lowerTorso.receiveShadow = true;
	leftShoulder.castShadow = true;
	leftShoulder.receiveShadow = true;
	leftArm.castShadow = true;
	leftArm.receiveShadow = true;
	rightShoulder.castShadow = true;
	rightShoulder.receiveShadow = true;
	rightArm.castShadow = true;
	rightArm.receiveShadow = true;
	leftHand.castShadow = true;
	leftHand.receiveShadow = true;
	rightHand.castShadow = true;
	rightHand.receiveShadow = true;
	head.castShadow = true;
	head.receiveShadow = true;
	waist.castShadow = true;
	waist.receiveShadow = true;
	leftThigh.castShadow = true;
	leftThigh.receiveShadow = true;
	rightThigh.castShadow = true;
	rightThigh.receiveShadow = true;
	rightCalf.castShadow = true;
	rightCalf.receiveShadow = true;
	leftCalf.castShadow = true;
	leftCalf.receiveShadow = true;
	rightFoot.castShadow = true;
	rightFoot.receiveShadow = true;
	leftFoot.castShadow = true;
	leftFoot.receiveShadow = true;
	targets.push(torso);
	scene.add(torsoDummy);
	}
}

function distance(x1, y1, x2, y2) 
{
	return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}

function getMapSector(v) 
{
	var x = Math.floor((v.x + UNITSIZE / 2) / UNITSIZE + mapW/2);
	var z = Math.floor((v.z + UNITSIZE / 2) / UNITSIZE + mapW/2);
	return {x: x, z: z};
}

/**
 * Check whether a Vector3 overlaps with a wall.
 *
 * @param v
 *   A THREE.Vector3 object representing a point in space.
 *   Passing cam.position is especially useful.
 * @returns {Boolean}
 *   true if the vector is inside a wall; false otherwise.
 */
function checkWallCollision(v)
{
	var c = getMapSector(v);
	return map[c.x][c.z] > 0;
}



var bullets = [];
var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x333333});
var sphereGeo = new THREE.SphereGeometry(.5, .5, 100);
var Material = new THREE.MeshLambertMaterial({color : 0xfb0000});
Material.side = THREE.DoubleSide;
function createBullet(obj) 
{
	if (obj === undefined) 
	{
		obj = cam;
	}
	var sphere = new THREE.Mesh(sphereGeo, sphereMaterial);
	sphere.position.set(obj.position.x, obj.position.y * 0.8, obj.position.z);

	if (obj instanceof THREE.Camera) 
	{
		var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
		//projector.unprojectVector(vector, obj);
		vector.unproject(obj);
		sphere.ray = new THREE.Ray(
				obj.position,
				vector.sub(obj.position).normalize()
		);
	}
	else 
	{
		var vector = cam.position.clone();
		sphere.ray = new THREE.Ray(
				obj.position,
				vector.subSelf(obj.position).normalize()
		);
	}
	sphere.owner = obj;
	
	bullets.push(sphere);
	scene.add(sphere);
	
	return sphere;
}

function onDocumentMouseDown(e)
{
  mouseCoords.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1
				);
				raycaster.setFromCamera( mouseCoords, cam );
				// Creates a ball and throws it
				var ballMass = 10;
				var ballRadius = 2;
        var ball = new THREE.Mesh( new THREE.SphereBufferGeometry( ballRadius, 14, 10 ), ballMaterial );
        var arrow = loader.load('../Project/images/Arrow.stl');
        console.log(arrow);
        
				ball.castShadow = true;
				ball.receiveShadow = true;
				var ballShape = new Ammo.btSphereShape( ballRadius );
				ballShape.setMargin( margin );
				pos.copy( raycaster.ray.direction );
				pos.add( raycaster.ray.origin );
				quat.set( 0, 0, 0, 1 );
				var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );
				pos.copy( raycaster.ray.direction );
				pos.multiplyScalar( 24 );
				ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
}

// Handle window resizing
$(window).resize(function() 
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	ASPECT = WIDTH / HEIGHT;
	if (cam) 
	{
		cam.aspect = ASPECT;
		cam.updateProjectionMatrix();
	}
	if (renderer) 
	{
		renderer.setSize(WIDTH, HEIGHT);
	}
	$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
});

// Stop moving around when the window is unfocused (keeps my sanity!)
$(window).focus(function() 
{
	if (controls) controls.freeze = false;
});
$(window).blur(function() 
{
	if (controls) controls.freeze = true;
});

//Get a random integer between lo and hi, inclusive.
//Assumes lo and hi are integers and lo is lower than hi.
function getRandBetween(lo, hi)
{
 return parseInt(Math.floor(Math.random()*(hi-lo+1))+lo, 10);
}

	
function removeDebris( object ) 
{
	scene.remove( object );
	physicsWorld.removeRigidBody( object.userData.physicsBody );
}
function createConvexHullPhysicsShape( coords ) 
{
	var shape = new Ammo.btConvexHullShape();
	for ( var i = 0, il = coords.length; i < il; i+= 3 ) 
	{
		tempBtVec3_1.setValue( coords[ i ], coords[ i + 1 ], coords[ i + 2 ] );
		var lastOne = ( i >= ( il - 3 ) );
		shape.addPoint( tempBtVec3_1, lastOne );
	}
	return shape;
}

function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) 
{
	if ( pos ) 
	{
		object.position.copy( pos );
	}
	else 
	{
		pos = object.position;
	}
	if ( quat ) 
	{
		object.quaternion.copy( quat );
	}
	else 
	{
		quat = object.quaternion;
	}
	var transform = new Ammo.btTransform();
	transform.setIdentity();
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
	var motionState = new Ammo.btDefaultMotionState( transform );
	var localInertia = new Ammo.btVector3( 0, 0, 0 );
	physicsShape.calculateLocalInertia( mass, localInertia );
	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
	var body = new Ammo.btRigidBody( rbInfo );
	body.setFriction( 0.5 );
	if ( vel ) 
	{
		body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
	}
	if ( angVel ) 
	{
		body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );
	}
	object.userData.physicsBody = body;
	object.userData.collided = false;
	scene.add( object );
	if ( mass > 0 )
	{
		rigidBodies.push( object );
		// Disable deactivation
		body.setActivationState( 4 );
	}
	physicsWorld.addRigidBody( body );
	return body;
}

	function initPhysics()
	 {
		// Physics configuration
		collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
		dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
		broadphase = new Ammo.btDbvtBroadphase();
		solver = new Ammo.btSequentialImpulseConstraintSolver();
		physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
		physicsWorld.setGravity( new Ammo.btVector3( 0, - gravityConstant/100, 0 ) );
	}

function updatePhysics( deltaTime ) 
{
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 );
	// Update rigid bodies
	for ( var i = 0, il = rigidBodies.length; i < il; i++ ) 
	{
		var objThree = rigidBodies[ i ];
		var objPhys = objThree.userData.physicsBody;
		var ms = objPhys.getMotionState();
		if ( ms ) 
		{
			ms.getWorldTransform( transformAux1 );
			var p = transformAux1.getOrigin();
			var q = transformAux1.getRotation();
			objThree.position.set( p.x(), p.y(), p.z() );
			objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			objThree.userData.collided = false;
		}
	}
	for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) 
	{
		var contactManifold = dispatcher.getManifoldByIndexInternal( i );
		var rb0 = contactManifold.getBody0();
		var rb1 = contactManifold.getBody1();
		var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
		var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;
		if ( ! threeObject0 && ! threeObject1 ) 
		{
			continue;
		}
		var userData0 = threeObject0 ? threeObject0.userData : null;
		var userData1 = threeObject1 ? threeObject1.userData : null;
		var breakable0 = userData0 ? userData0.breakable : false;
		var breakable1 = userData1 ? userData1.breakable : false;
		var collided0 = userData0 ? userData0.collided : false;
		var collided1 = userData1 ? userData1.collided : false;
		if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) 
		{
			continue;
		}
		var contact = false;
		var maxImpulse = 0;
		for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) 
		{
			var contactPoint = contactManifold.getContactPoint( j );
			if ( contactPoint.getDistance() < 0 ) 
			{
				contact = true;
				var impulse = contactPoint.getAppliedImpulse();
				if ( impulse > maxImpulse ) 
				{
					maxImpulse = impulse;
					var pos = contactPoint.get_m_positionWorldOnB();
					var normal = contactPoint.get_m_normalWorldOnB();
					impactPoint.set( pos.x(), pos.y(), pos.z() );
					impactNormal.set( normal.x(), normal.y(), normal.z() );
				}
				break;
			}
		}
		// If no point has contact, abort
		if ( ! contact ) 
		{
			continue;
		}
		// Subdivision
		var fractureImpulse = 250;
		if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) 
		{
			var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
			userData0.collided = true;
		}
		if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) 
		{
			var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
			userData1.collided = true;
		}
	}
	for ( var i = 0; i < numObjectsToRemove; i++ ) 
	{
		removeDebris( objectsToRemove[ i ] );
	}
	numObjectsToRemove = 0;
}
function createRandomColor() 
{
	return Math.floor( Math.random() * ( 1 << 24 ) );
}
function createMaterial( color ) 
{
	color = color || createRandomColor();
	return new THREE.MeshPhongMaterial( { color: color } );
}
</script>
</html>