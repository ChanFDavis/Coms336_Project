<!DOCTYPE html>
<html>
<head>
  <title>WebGL Multiplayer Target</title>
  <link rel="stylesheet" type="text/css" href="index_style.css">
  <script src="jquery-1.7.2.min.js"></script>

  <script src="/three.js-master/build/three.js"></script>
  <script src="Three.FirstPersonControls.js"></script>
  <script src="/three.js-master/examples/js/renderers/Projector.js"></script>
  <script src="/Player.js"></script>
  <!-- <script src="main.js"></script> -->
  <script src="/three.js-master/examples/js/libs/ammo.js"></script>
	<script src="/three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script src="/three.js-master/examples/js/WebGL.js"></script>
	<script src="/three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="/three.js-master/examples/js/ConvexObjectBreaker.js"></script>
	<script src="/three.js-master/examples/js/QuickHull.js"></script>
  <script src="/three.js-master/examples/js/geometries/ConvexGeometry.js"></script>
  <script src="/three.js-master/examples/js/loaders/STLLoader.js"></script>
  <script src="/three.js-master/examples/js/loaders/PLYLoader.js"></script>
  <script src="/three.js-master/src/loaders/TextureLoader.js"></script>

</head>
<body>
</body>
<script>

// Initalize the map where '1' represents a "wall".
var map = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]];
var mapW = map.length;
var mapH = map[0].length;

// Semi-constants
var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;
var ASPECT_RATIO = WIDTH / HEIGHT;
var UNIT_SIZE = 250;
var BULLET_SPEED = 500;
var PROJECTILE_DAMAGE = 20;
var ARROW_SPEED = 1;
var GRAVITY = 9.81;

// Global vars
var scene, cam, backgroundScene, backgroundCamera, renderer, controls, clock, projector, model, skin;
var runAnim = true
var mouseCoords = new THREE.Vector2();
var container, stats;
var textureLoader;
var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
var loader = new THREE.STLLoader();

// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;

var rigidBodies = [];
var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
var time = 0;
var objectsToRemove = [];
for ( var i = 0; i < 500; i++ ) 
{
	objectsToRemove[ i ] = null;
}
var numObjectsToRemove = 0;
var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();
var hBar = $('.health-bar');
var bar = hBar.find('.bar');
var hit = hBar.find('.hit');
var pBar = $('.power-bar'),
power = pBar.find('.power');

// Initialize and run on document ready
$(document).ready(function() 
{
	$('body').append('<div id="intro">Click to start</div>');
	$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) 
	{
		e.preventDefault();
		$(this).fadeOut();
  	    init();
  	    initPhysics();
		//setInterval(drawWind, 1000);
		animate();
	});
});

// Setup
function init() 
{
	clock = new THREE.Clock(); // Used in render() for controls.update()
	projector = new THREE.Projector(); // Used in bullet projection
	scene = new THREE.Scene(); // Holds all objects in the canvas
	//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0005); // color, density
	
	// Set up camera
	cam = new THREE.PerspectiveCamera(60, ASPECT_RATIO, 1, 10000); // FOV, aspect, near, far
	cam.position.y = 130;
	cam.position.x = 0;
	cam.position.z = -1125;
	scene.add(cam);
	
	// Camera moves with mouse, flies around with WASD/arrow keys
	controls = new THREE.FirstPersonControls(cam);
	controls.movementSpeed = 600;
	controls.lookSpeed = .15;
	
	controls.lookVertical = true; // Temporary solution; play on flat surfaces only
	controls.noFly = true;
	
	// World objects
	setupScene();
	initTargets();
	
	// Handle drawing as WebGL (faster than Canvas but less supported)
	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(WIDTH, HEIGHT);
	var spotLight = new THREE.SpotLight( 0xF7EFBE );
	spotLight.position.set( 0, 1000, 0 );

	spotLight.castShadow = true;

	spotLight.shadow.mapSize.width = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;
	spotLight.shadow.mapSize.height = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;

	spotLight.shadow.camera.near = 1;
	spotLight.shadow.camera.far = 10000;
	spotLight.shadow.camera.fov = 60;

	scene.add(spotLight);
	
	// Add the canvas to the document
	document.body.appendChild(renderer.domElement);
	
	// Track mouse position so we know where to shoot
  	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener('mouseup', onDocumentMouseUp, false);
	
	// Display HUD
	$('body').append('<div id="hud"><p>Health: <span id="health">100</span><br />Score: <span id="score">0</span></p></div>');
	$('body').append('<div class="health-bar" data-total="1000" data-value="1000"><div class="bar"><div class="hit"></div></div></div>');
	$('body').append('<div class="power-bar" data-total="1000" data-value="0"><div class="power"></div></div>');
	
	// Set up "hurt" flash
	$('body').append('<div id="hurt"></div>');
	$('#hurt').css({width: WIDTH, height: HEIGHT,});
}

// Helper function for browser frames
function animate() 
{
	if (runAnim) 
	{
		requestAnimationFrame(animate);
	}
	render();
}

// Update and display
function render() 
{
  	var delta = clock.getDelta();
  	var speed = delta * BULLET_SPEED;

	controls.update(delta); // Move camera
	updatePhysics( speed );
	
	// Update bullets. Walk backwards through the list so we can remove items.
	for (var i = bullets.length-1; i >= 0; i--) 
	{
		var b = bullets[i], p = b.position, d = b.ray.direction;
		if (checkWallCollision(p)) 
		{
			bullets.splice(i, 1);
			scene.remove(b);
			continue;
		}
		// Collide with AI
		var hit = false;
		for (var j = targets.length-1; j >= 0; j--) 
		{
			var curPlayer = targets[j];
			var v = curPlayer.torso.geometry.vertices[0];
			var c = curPlayer.torso.position;
			var x = Math.abs(v.x), z = Math.abs(v.z);
			//console.log(Math.round(p.x), Math.round(p.z), c.x, c.z, x, z);
			if (p.x < c.x + x && p.x > c.x - x &&
					p.z < c.z + z && p.z > c.z - z &&
					b.owner != a) 
					{
				bullets.splice(i, 1);
				scene.remove(b);
				curPlayer.health -= PROJECTILE_DAMAGE;
				var color = curPlayer.torso.material.color, percent = curPlayer.health / 100;
				curPlayer.torso.material.color.setRGB(
						percent * color.r,
						percent * color.g,
						percent * color.b
				);
				hit = true;
				break;
			}
		}
		b.translateX(speed * d.x);
		b.translateZ(speed * d.z);
  	}
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(backgroundScene, backgroundCamera)
	renderer.render(scene, cam); // Repaint
	time += delta;
	//console.log(cam.rotation.y);
}

// Set up the objects in the world
function setupScene() 
{
	// Initialize the floor

	var floorGeo = new THREE.CubeGeometry(mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE);
	floorGeo.computeVertexNormals();
	floorGeo.computeFaceNormals();
	
	var floor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({color: 0xEDCBA0}));
	scene.add(floor);
	

	// Lighting

	var directionalLight1 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight1.position.set( .5, .9, .5);
	directionalLight1.castShadow = true;
	scene.add( directionalLight1 );

	var directionalLight2 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight2.position.set( -.5, .9, -.5);
	directionalLight2.castShadow = true;
	scene.add( directionalLight2 );
	

	// Background

	// Load the background texture
	var texture = new THREE.TextureLoader().load('images/Top-Header-Grass-Sky-Background-JPG.jpg');
	var backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: texture}));

	// The background (skybox) should have no effect on depth buffer.
	backgroundMesh.material.depthTest = false;
	backgroundMesh.material.depthWrite = false;

	// Create your background scene
	backgroundScene = new THREE.Scene();
	backgroundCamera = new THREE.Camera();

	// Add the background to the scene.
	backgroundScene.add(backgroundCamera);
	backgroundScene.add(backgroundMesh);
}

var targets = [];

// Holds the Player objects for our game.
var player1;
var player2;

function initTargets() 
{
	// Add player one
	player1 = new Player(0xff0000, new THREE.Vector3(1000, 168/2, 1000), new THREE.Euler(0, 1.5708 * 2, 0));

	targets.push(player1.torso);
	scene.add(player1.torsoDummy);

	// Add player two
	player2 = new Player(0x0000ff, new THREE.Vector3(-1000, 168/2, -1000), new THREE.Euler(0, 0, 0));

	targets.push(player2.torso);
	scene.add(player2.torsoDummy);
}

function distance(x1, y1, x2, y2) 
{
	return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}

function getMapSector(v) 
{
	var x = Math.floor((v.x + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	var z = Math.floor((v.z + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	return {x: x, z: z};
}

/**
 * Check whether a Vector3 overlaps with a wall.
 *
 * @param v
 *   A THREE.Vector3 object representing a point in space.
 *   Passing cam.position is especially useful.
 * @returns {Boolean}
 *   true if the vector is inside a wall; false otherwise.
 */
function checkWallCollision(v)
{
	var c = getMapSector(v);
	return map[c.x][c.z] > 0;
}


var bullets = [];
var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x333333});
var sphereGeo = new THREE.SphereGeometry(.5, .5, 100);
var Material = new THREE.MeshLambertMaterial({color : 0xfb0000});
Material.side = THREE.DoubleSide;
function createBullet(obj) 
{
	if (obj === undefined) 
	{
		obj = cam;
	}
	var sphere = new THREE.Mesh(sphereGeo, sphereMaterial);
	sphere.position.set(obj.position.x, obj.position.y * 0.8, obj.position.z);

	if (obj instanceof THREE.Camera) 
	{
		var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
		//projector.unprojectVector(vector, obj);
		vector.unproject(obj);
		sphere.ray = new THREE.Ray(
				obj.position,
				vector.sub(obj.position).normalize()
		);
	}
	else 
	{
		var vector = cam.position.clone();
		sphere.ray = new THREE.Ray(
				obj.position,
				vector.subSelf(obj.position).normalize()
		);
	}
	sphere.owner = obj;
	
	bullets.push(sphere);
	scene.add(sphere);
	
	return sphere;
}

var mousedownID = -1;
var pow = .1;
function onDocumentMouseDown(e)
{
	// Reset the power and arrow speed.
	pow = .1;
	ARROW_SPEED = 1;
	$('.power').css({width: 0+"%",});
	$('.power-bar').css({value: 0,});
	// Prevent infinite loop.
	if(mousedownID == -1)
	{
		mousedownID = setInterval(whileMouseDown, 100 /*execute every 100ms*/);
	}  
    
}
function whileMouseDown()
{
	// While holding mouse down, increase arrow power.
	ARROW_SPEED += 1;

	physicsWorld.setGravity( new Ammo.btVector3(0, -GRAVITY/100, 0) );

	// Grab CSS of the power bar.
	var value = $('.power-bar').data('value');
	var total = $('.power-bar').data('total');
	
	// Update the value based on power.
    var newValue = pow;
	pow += .01;
	var barWidth = (newValue / total) * 100;
	if(pow *100 < 100)
	{
		var hitWidth = (pow) * 100 + "%";
	}
    else
	{
		var hitWidth = 100 + "%";
	}
    // Update the data of the CSS.
	$('.power').css({width: hitWidth,});
	$('.power-bar').css({value: newValue,});
}

function onDocumentMouseUp(e)
{
	if(mousedownID!=-1) 
	{  //Only stop if exists
     clearInterval(mousedownID);
     mousedownID=-1;
   }
  mouseCoords.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1
				);
				raycaster.setFromCamera( mouseCoords, cam );
				// Creates a ball and throws it
				var ballMass = 1;
				var ballRadius = 2;
        var ball = new THREE.Mesh( new THREE.SphereBufferGeometry( ballRadius, 14, 10 ), ballMaterial );
        var arrow = loader.load('/models/Arrow.stl');
             
				ball.castShadow = true;
				ball.receiveShadow = true;
				var ballShape = new Ammo.btSphereShape( ballRadius );
				ballShape.setMargin( margin );
				pos.copy( raycaster.ray.direction );
				pos.add( raycaster.ray.origin );
				quat.set( 0, 0, 0, 1 );
				var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );
				pos.copy( raycaster.ray.direction );
				pos.multiplyScalar( 24 );
				ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
}


// Handle window resizing
$(window).resize(function() 
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	ASPECT_RATIO = WIDTH / HEIGHT;
	if (cam) 
	{
		cam.aspect = ASPECT_RATIO;
		cam.updateProjectionMatrix();
	}
	if (renderer) 
	{
		renderer.setSize(WIDTH, HEIGHT);
	}
	$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
});

// Stop moving around when the window is unfocused (keeps my sanity!)
$(window).focus(function() 
{
	if (controls) controls.freeze = false;
});
$(window).blur(function() 
{
	if (controls) controls.freeze = true;
});

//Get a random integer between lo and hi, inclusive.
//Assumes lo and hi are integers and lo is lower than hi.
function getRandBetween(lo, hi)
{
 return parseInt(Math.floor(Math.random()*(hi-lo+1))+lo, 10);
}

	
function removeDebris( object ) 
{
	scene.remove( object );
	physicsWorld.removeRigidBody( object.userData.physicsBody );
}
function createConvexHullPhysicsShape( coords ) 
{
	var shape = new Ammo.btConvexHullShape();
	for ( var i = 0, il = coords.length; i < il; i+= 3 ) 
	{
		tempBtVec3_1.setValue( coords[ i ], coords[ i + 1 ], coords[ i + 2 ] );
		var lastOne = ( i >= ( il - 3 ) );
		shape.addPoint( tempBtVec3_1, lastOne );
	}
	return shape;
}

function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) 
{
	if ( pos ) 
	{
		object.position.copy( pos );
	}
	else 
	{
		pos = object.position;
	}
	if ( quat ) 
	{
		object.quaternion.copy( quat );
	}
	else 
	{
		quat = object.quaternion;
	}
	var transform = new Ammo.btTransform();
	transform.setIdentity();
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
	var motionState = new Ammo.btDefaultMotionState( transform );
	var localInertia = new Ammo.btVector3( 0, 0, 0 );
	physicsShape.calculateLocalInertia( mass, localInertia );
	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
	var body = new Ammo.btRigidBody( rbInfo );
	body.setFriction( 0.5 );
	if ( vel ) 
	{
		body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
	}
	if ( angVel ) 
	{
		body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );
	}
	object.userData.physicsBody = body;
	object.userData.collided = false;
	scene.add( object );
	if ( mass > 0 )
	{
		rigidBodies.push( object );
		// Disable deactivation
		body.setActivationState( 4 );
	}
	physicsWorld.addRigidBody( body );
	return body;
}

	function initPhysics()
	 {
		// Physics configuration
		collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
		dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
		broadphase = new Ammo.btDbvtBroadphase();
		solver = new Ammo.btSequentialImpulseConstraintSolver();
		physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
		physicsWorld.setGravity( new Ammo.btVector3((2*Math.PI), - GRAVITY, (2*Math.PI)));
		
	}

function updatePhysics( deltaTime ) 
{
	
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 );
	// Update rigid bodies
	for ( var i = 0, il = rigidBodies.length; i < il; i++ ) 
	{
		var objThree = rigidBodies[ i ];
		var objPhys = objThree.userData.physicsBody;
		var ms = objPhys.getMotionState();
		if ( ms ) 
		{
			ms.getWorldTransform( transformAux1 );
			var p = transformAux1.getOrigin();
			var q = transformAux1.getRotation();
			
			objThree.position.set(p.x(), p.y(), p.z());
			
			objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			objThree.userData.collided = false;
		}
	}
	for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) 
	{
		var contactManifold = dispatcher.getManifoldByIndexInternal( i );
		var rb0 = contactManifold.getBody0();
		var rb1 = contactManifold.getBody1();
		var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
		var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;
		if ( ! threeObject0 && ! threeObject1 ) 
		{
			continue;
		}
		var userData0 = threeObject0 ? threeObject0.userData : null;
		var userData1 = threeObject1 ? threeObject1.userData : null;
		var breakable0 = userData0 ? userData0.breakable : false;
		var breakable1 = userData1 ? userData1.breakable : false;
		var collided0 = userData0 ? userData0.collided : false;
		var collided1 = userData1 ? userData1.collided : false;
		if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) 
		{
			continue;
		}
		var contact = false;
		var maxImpulse = 0;
		for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) 
		{
			var contactPoint = contactManifold.getContactPoint( j );
			if ( contactPoint.getDistance() < 0 ) 
			{
				contact = true;
				var impulse = contactPoint.getAppliedImpulse();
				if ( impulse > maxImpulse ) 
				{
					maxImpulse = impulse;
					var pos = contactPoint.get_m_positionWorldOnB();
					var normal = contactPoint.get_m_normalWorldOnB();
					impactPoint.set( pos.x(), pos.y(), pos.z() );
					impactNormal.set( normal.x(), normal.y(), normal.z() );
				}
				break;
			}
		}
		// If no point has contact, abort
		if ( ! contact ) 
		{
			continue;
		}
		// Subdivision
		var fractureImpulse = 250;
		if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) 
		{
			var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
			userData0.collided = true;
		}
		if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) 
		{
			var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
			userData1.collided = true;
		}
	}
	for ( var i = 0; i < numObjectsToRemove; i++ ) 
	{
		removeDebris( objectsToRemove[ i ] );
	}
	numObjectsToRemove = 0;
}
function createRandomColor() 
{
	return Math.floor( Math.random() * ( 1 << 24 ) );
}
function createMaterial( color ) 
{
	color = color || createRandomColor();
	return new THREE.MeshPhongMaterial( { color: color } );
}

function getRandomArbitrary(min, max) 
{
  	return Math.random() * (max - min) + min;
}
</script>
</html>