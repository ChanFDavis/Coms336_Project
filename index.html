<!DOCTYPE html>
<html>
<head>
	<title>WebGL Multiplayer Target</title>

	<link rel="stylesheet" type="text/css" href="index_style.css">
	
	<script src="jquery-1.7.2.min.js"></script>

	<script src="three.js-master/build/three.js"></script>

	<script src="three.js-master/examples/js/renderers/Projector.js"></script>
	<script src="three.js-master/examples/js/libs/ammo.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script src="three.js-master/examples/js/WebGL.js"></script>
	<script src="three.js-master/examples/js/ConvexObjectBreaker.js"></script>
	<script src="three.js-master/examples/js/QuickHull.js"></script>
	<script src="three.js-master/examples/js/geometries/ConvexGeometry.js"></script>
	<script src="three.js-master/examples/js/loaders/PLYLoader.js"></script>
	<script src="three.js-master/examples/js/geometries/hilbert3D.js"></script>
	<script src='three.js-master/examples/js/lines/LineSegmentsGeometry.js'></script>
	<script src='three.js-master/examples/js/lines/LineGeometry.js'></script>
	<script src='three.js-master/examples/js/lines/WireframeGeometry2.js'></script>

	<script src='three.js-master/examples/js/lines/LineMaterial.js'></script>

	<script src='three.js-master/examples/js/lines/LineSegments2.js'></script>
	<script src='three.js-master/examples/js/lines/Line2.js'></script>
	<script src='three.js-master/examples/js/lines/Wireframe.js'></script>
	
	<script src="three.js-master/src/loaders/TextureLoader.js"></script>
	<script src="Three.FirstPersonControls.js"></script>

	<script src="Player.js"></script>
	<script src="three.js-master/examples/js/GPUParticleSystem.js"></script>
</head>

<body>
</body>

<script>

// Initalize the map where '1' represents a "wall".
var map = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,], 
		  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]];
var mapW = map.length;
var mapH = map[0].length;

// Semi-constants
var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;
var ASPECT_RATIO = WIDTH / HEIGHT;
var UNIT_SIZE = 250;
var BULLET_SPEED = 500;
var PROJECTILE_DAMAGE = 333.3;
var ARROW_SPEED = 1;
var GRAVITY = 9.81;

// Global vars
var scene, cam, backgroundScene, backgroundCamera, renderer, controls, clock, projector, model, skin, textureCube;
var runAnim = true;
var mouseCoords = new THREE.Vector2();
var container, stats;
var textureLoader;
var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
var loader = new THREE.PLYLoader();
var mousedownID = -1;
var pow = .1;
var testArrow;
var particleCount = 1800,
    particles = new THREE.Geometry(),
    pMaterial = new THREE.PointsMaterial({
      color: 0xFFFFFF,
      size: 20
	});
var particleSystem;
// Holds the Player objects for our game.
var players = [];

var player1;
var player2;

// Physics variables
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;
var wind;

var rigidBodies = [];
var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
var time = 0;
var objectsToRemove = [];
for ( var i = 0; i < 500; i++ ) 
{
	objectsToRemove[ i ] = null;
}
var numObjectsToRemove = 0;
var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Initialize and run on document ready
$(document).ready(function() 
{
	$('body').append('<div id="intro">Click to start</div>');
	$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) 
	{
		e.preventDefault();
		$(this).fadeOut();
		 init();
		 initWind();
		 initPhysics();
		//setInterval(drawWind, 1000);
		animate();
	});
});

// Setup
function init() 
{
	clock = new THREE.Clock(); // Used in render() for controls.update()
	projector = new THREE.Projector(); // Used in bullet projection
	scene = new THREE.Scene(); // Holds all objects in the canvas
	//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0005); // color, density
	
	// Set up camera
	cam = new THREE.PerspectiveCamera(40, ASPECT_RATIO, 1, 10000); // FOV, aspect, near, far
	cam.position.y = 130;
	cam.position.x = 0;
	cam.position.z = -1125;
	cam.lookAt(new THREE.Vector3( 0, 84, 1125 ));
	scene.add(cam);
	
	// Camera moves with mouse, flies around with WASD/arrow keys
	controls = new THREE.FirstPersonControls(cam);
	controls.freeze = true;
	controls.movementSpeed = 600;
	controls.lookSpeed = .15;
	
	controls.lookVertical = true; // Temporary solution; play on flat surfaces only
	controls.noFly = true;
	
	// World objects
	setupScene();
	initPlayers();
	
	// Handle drawing as WebGL (faster than Canvas but less supported)
	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(WIDTH, HEIGHT);
	var spotLight = new THREE.SpotLight( 0xF7EFBE );
	spotLight.position.set( 0, 1000, 0 );

	spotLight.castShadow = true;

	spotLight.shadow.mapSize.width = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;
	spotLight.shadow.mapSize.height = mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE;

	spotLight.shadow.camera.near = 1;
	spotLight.shadow.camera.far = 10000;
	spotLight.shadow.camera.fov = 60;

	scene.add(spotLight);
	
	// Add the canvas to the document
	document.body.appendChild(renderer.domElement);
	
	// Track mouse position so we know where to shoot
	document.addEventListener('mousedown', onDocumentMouseDown, false);
	document.addEventListener('mouseup', onDocumentMouseUp, false);
	document.addEventListener('mousemove', onDocumentMouseMove, false);
	
	// Display HUD
	//$('body').append('<div id="hud"><p>Health: <span id="health">100</span><br />Score: <span id="score">0</span></p></div>');
	$('body').append('<div id="p1" class="health-bar" data-total="1000" data-value="1000"><div class="bar"><div class="hit"></div></div></div>');
	$('body').append('<div id="p2" class="health-bar2" data-total="1000" data-value="1000"><div class="bar2"><div class="hit2"></div></div></div>');
	$('body').append('<div class="power-bar" data-total="1000" data-value="0"><div class="power"></div></div>');
	
	// Set up "hurt" flash
	$('body').append('<div id="hurt"></div>');
	$('#hurt').css({width: WIDTH, height: HEIGHT,});
	
// also update the particle system to
// sort the particles which enables
// the behaviour we want

}

// Helper function for browser frames
function animate() {
	if (runAnim) {	requestAnimationFrame(animate); update();}
	render();
}
function update()
{
	if(particleSystem)
	{//console.log(particles);
		//console.log(particleSystem);
		//particleSystem.rotation.y += 0.01;
		for (let i = 0; i < particleCount; i++) 
		{
			var particle = particles.vertices[i];
			
			particle.x = Math.random() * 500 - 250;
			particle.y = Math.random() * 500 - 250;
			particle.z = Math.random() * 500 - 250;
		}
		particles.verticesNeedUpdate = true;
	}
}
// Update and display
function render() 
{
	var player1Health = $('.health-bar').data('value');
	var player2Health = $('.health-bar2').data('value');
	var total = $('.health-bar').data('total');
	
	
	
	if(player1Health <= 1 || player2Health <= 1)
	{
		let winner = player1Health > player2Health ? "Player 1" : "Player 2";
		runAnim = false;
		$(renderer.domElement).fadeOut();
		$('#intro').fadeIn();
		$('#intro').html(winner +' wins! Click to restart...');
		$('#intro').one('click', function() {
			location = location;
		});
	}
	var delta = clock.getDelta();
	var speed = delta * BULLET_SPEED;

	controls.update(delta); // Move camera
	updatePhysics( speed );
	for (let index = 0; index < rigidBodies.length; index++) 
	{
		let thisArrow = rigidBodies[index];
		if(thisArrow.position.x > 2000 || thisArrow.position.x < -2000 || thisArrow.position.z > 2000 || thisArrow.position.z < -2000)
		{
			scene.remove(thisArrow);
			rigidBodies.shift();
			continue;
		}
		if(rigidBodies[index])
		{
			for (var vertexIndex = 0; vertexIndex < rigidBodies[index].geometry.attributes.position.array.length/3; vertexIndex++)
			{       
				var localVertex = new THREE.Vector3(rigidBodies[index].geometry.attributes.position.array[vertexIndex *3],rigidBodies[index].geometry.attributes.position.array[vertexIndex*3+1],rigidBodies[index].geometry.attributes.position.array[vertexIndex*3+2]);
				var globalVertex = localVertex.applyMatrix4(rigidBodies[index].matrix);
				var directionVector = globalVertex.sub( rigidBodies[index].position );

				var ray = new THREE.Raycaster( rigidBodies[index].position, directionVector.clone().normalize() );
				var collisionResults = ray.intersectObjects( players );
				vertexIndex += 3;
			
				if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
				{
					//player1.torsoDummy.add(rigidBodies[index]);
					//scene.remove(rigidBodies[index]);
					rigidBodies.shift();
					
					if(cam.position.z > 0)
					{
						var newValue2 = player1Health - PROJECTILE_DAMAGE;
						var barWidth = (newValue2 / total) * 100;
						var hitWidth = (PROJECTILE_DAMAGE / player1Health) * 100 + "%";
					
						$('.hit').css({width: hitWidth,});
						$('.health-bar').data({value: newValue2,});
						setTimeout(function(){
							$('.hit').css({width: '0',});
							$('.bar').css({width: barWidth + "%",});
							}, 500);
						loader = new THREE.TextureLoader();
						loader.load('textures/particle2.png', function( texture ){
							var pMaterial = new THREE.PointsMaterial( {
								color: 0xFF0000,
								size: 20,
								map: texture,
								//blending: THREE.AdditiveBlending,
								transparent: true
							});
						for (var p = 0; p < particleCount; p++) {

							// create a particle with random
							// position values, -250 -> 250
							var pX = Math.random() * 500 - 250,
								pY = Math.random() * 500 - 250,
								pZ = Math.random() * 500 - 250,
								particle = new THREE.Vector3(pX, pY, pZ);
								particle.velocity = new THREE.Vector3(
								0,				// x
								-Math.random(),	// y
								0);				// z
							// add it to the geometry
							particles.vertices.push(particle);
							}
							particleSystem = new THREE.Points(
							particles,
							pMaterial);
							particleSystem.sortParticles = true;
							scene.add(particleSystem);
							
						});
					}
					else
					{
						var newValue2 = player2Health - PROJECTILE_DAMAGE;
						var barWidth = (newValue2 / total) * 100;
						var hitWidth = (PROJECTILE_DAMAGE / player2Health) * 100 + "%";
					
						$('.hit2').css({width: hitWidth,});
						$('.health-bar2').data({value: newValue2,});
						setTimeout(function(){
							$('.hit2').css({width: '0',});
							$('.bar2').css({width: barWidth + "%",});
							}, 500);
						loader = new THREE.TextureLoader();
						loader.load('textures/particle2.png', function( texture ){
							var pMaterial = new THREE.PointsMaterial( {
								color: 0xFF0000,
								size: 20,
								map: texture,
								//blending: THREE.AdditiveBlending,
								transparent: true
							});
						for (var p = 0; p < particleCount; p++) {

							// create a particle with random
							// position values, -250 -> 250
							var pX = Math.random() * 500 - 250,
								pY = Math.random() * 500 - 250,
								pZ = Math.random() * 500 - 250,
								particle = new THREE.Vector3(pX, pY, pZ);
								particle.velocity = new THREE.Vector3(
								0,				// x
								-Math.random(),	// y
								0);				// z
							// add it to the geometry
							particles.vertices.push(particle);
							}
							particleSystem = new THREE.Points(
							particles,
							pMaterial);
							particleSystem.sortParticles = true;
							scene.add(particleSystem);
							
						});
					}
				
				}
			}
		}
	}
	let arrowDir = scene.getObjectByName("arrowDir");
	if(arrowDir)
	{
		raycaster.setFromCamera( mouseCoords, cam );
		arrowDir.setDirection(raycaster.ray.direction);
	}

	let newArrowDir = scene.getObjectByName("newArrowDir");
	if(newArrowDir)
	{
		scene.remove(scene.getObjectByName("newArrowDir"));
		var numPoints = 100;

		var spline = new THREE.CatmullRomCurve3([
		new THREE.Vector3(0,129,-1125),
		new THREE.Vector3(0,129,-1125)
		]);
		for (let i = 1; i < 51; i++) {
			spline.points.push(new THREE.Vector3(wind.x*i +100, 120, i*5))
			
		}
		//console.log(wind);
		var material = new THREE.LineBasicMaterial({
			color: 0xff00f0,
			linewidth: 50,
		});

		var geometry = new THREE.Geometry();
		var splinePoints = spline.getPoints(numPoints);

		for(var i = 0; i < splinePoints.length; i++){
			geometry.vertices.push(splinePoints[i]);  
		}

		var line = new THREE.Line(geometry, material);
		line.name = "newArrowDir";
		scene.add(line);
	}

	
	cameraCube.rotation.copy( cam.rotation );
	//cameraCube.rotation.y += .001;
	renderer.autoClear = false;
	renderer.gammaOutput = true;
	//renderer.clear();
	renderer.render(backgroundScene, cameraCube);
	renderer.render(scene, cam); // Repaint
	time += delta;
}

// Set up the objects in the world
function setupScene() 
{
	// Initialize the floor
	var floorGeo = new THREE.CubeGeometry(mapW * UNIT_SIZE, 10, mapW * UNIT_SIZE);
	floorGeo.computeVertexNormals();
	floorGeo.computeFaceNormals();
	
	loader = new THREE.TextureLoader();
	loader.load('/three.js-master/examples/textures/terrain/grasslight-big.jpg', function( texture ){
		var floorMat = new THREE.MeshBasicMaterial( {
			map: texture
		});
		var floor = new THREE.Mesh(floorGeo, floorMat);
	scene.add(floor);
	});
	

	var loader = new THREE.PLYLoader();
				loader.load( 'models/wind.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					var material = new THREE.MeshStandardMaterial( { color: 0x4d2600, flatShading: true } );
					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.y = 75;
					mesh.position.x = 100;
					mesh.position.z = -900;
					mesh.rotation.x = - Math.PI / 2;
					let angle = Math.atan2(wind.z,-wind.x);
					mesh.rotation.z = angle;
					mesh.rotation.z += (1.5708*2); 
					mesh.scale.multiplyScalar( .1 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );
				} );

	var loader = new THREE.PLYLoader();
				loader.load( 'models/wind.ply', function ( geometry ) {
					geometry.computeVertexNormals();
					var material = new THREE.MeshStandardMaterial( { color: 0x4d2600, flatShading: true } );
					var mesh2 = new THREE.Mesh( geometry, material );
					mesh2.position.y = 75;
					mesh2.position.x = -100;
					mesh2.position.z = 900;
					mesh2.rotation.x = - Math.PI / 2;
					let angle = Math.atan2(wind.z,-wind.x);
					mesh2.rotation.z = angle;
					mesh2.rotation.z += (1.5708*2); 
					mesh2.scale.multiplyScalar( .1 );
					mesh2.castShadow = true;
					mesh2.receiveShadow = true;
					scene.add( mesh2 );
				} );

	var arrowMark = new THREE.ArrowHelper(
		new THREE.Vector3(0,0,1), new THREE.Vector3(0,130,-1125), 1000, 0x884400);
	arrowMark.name = "arrowDir";
	//scene.add(arrowMark);


// smooth my curve over this many points
var numPoints = 100;

spline = new THREE.SplineCurve3([
   new THREE.Vector3(0,129,-1125),
   new THREE.Vector3(0,129,-1125)
  
]);

var material = new THREE.LineBasicMaterial({
	color: 0xff00f0,
	linewidth: 50,
});

var geometry = new THREE.Geometry();
var splinePoints = spline.getPoints(numPoints);

for(var i = 0; i < splinePoints.length; i++){
    geometry.vertices.push(splinePoints[i]);  
}

var line = new THREE.Line(geometry, material);
line.name = "newArrowDir";
//scene.add(line);// smooth my curve over this many points


						
	// Lighting
	var directionalLight1 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight1.position.set( .5, .9, .5);
	directionalLight1.castShadow = true;
	scene.add( directionalLight1 );

	var directionalLight2 = new THREE.DirectionalLight(0xF7EFBE, .5);
	directionalLight2.position.set( -.5, .9, -.5);
	directionalLight2.castShadow = true;
	scene.add( directionalLight2 );

	// Background

	// Load the background texture
	var texture = new THREE.TextureLoader().load('images/dbz-bg.jpg');
	var backgroundMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: texture}));

	// The background (skybox) should have no effect on depth buffer.
	backgroundMesh.material.depthTest = false;
	backgroundMesh.material.depthWrite = false;

	// Create your background scene
	backgroundScene = new THREE.Scene();
	backgroundCamera = new THREE.Camera();
	cameraCube = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
	backgroundMesh.name = "bg";


	var r = "images/skybox/";
				var urls = [ r + "skybox_px.jpg", r + "skybox_nx.jpg",
							 r + "skybox_py.jpg", r + "skybox_ny.jpg",
							 r + "skybox_pz.jpg", r + "skybox_nz.jpg" ];
	textureCube = new THREE.CubeTextureLoader().load( urls );
	textureCube.format = THREE.RGBFormat;
	textureCube.mapping = THREE.CubeReflectionMapping;
	textureCube.encoding = THREE.sRGBEncoding;
	var cubeShader = THREE.ShaderLib[ "cube" ];
				var cubeMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				} );
				cubeMaterial.uniforms[ "tCube" ].value = textureCube;
				Object.defineProperty( cubeMaterial, 'map', {
					get: function () {
						return this.uniforms.tCube.value;
					}
				} );
				cubeMesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 100, 100, 100 ), cubeMaterial );
				
				backgroundScene.add( cubeMesh );
	// Add the background to the scene.
	backgroundScene.add(cameraCube);
	//backgroundScene.add(backgroundMesh);
}

function initPlayers() 
{
	// Add player one's bow object to scene
	var bow1 = new THREE.Object3D();
	bow1.name = "bow1";		
	bow1.position.y = -25;
	bow1.position.x = 0;
	bow1.position.z = -36;
	scene.add(bow1);

	// Add player one's bow object to scene
	var bow2 = new THREE.Object3D();
	bow2.name = "bow2";		
	bow2.position.y = -25;
	bow2.position.x = 0;
	bow2.position.z = -36;
	scene.add(bow2);

	console.log(scene.children);

	// Load the PLY model for the bows and assign the meshes to their corresponding objects.
	loader.load( 'models/bow.ply', function ( geometry ) {
		geometry.computeVertexNormals();
		
		var material = new THREE.MeshStandardMaterial( { color: 0x7c440b, flatShading: true } );
		var mesh = new THREE.Mesh( geometry, material );
		mesh.rotateZ(1.5708);
		mesh.scale.multiplyScalar( .35 );

		let parent1 = scene.getObjectByName("bow1");
		if(parent1) {
			parent1.add(mesh);
		}		

		let parent2 = scene.getObjectByName("bow2");
		if(parent2) {
			parent2.add(mesh);
		}
	});

	// Add player one
	player1 = new Player(0xff0000, new THREE.Vector3(0, 84, -1125), new THREE.Euler(0, 0, 0));
	player1.leftHandDummy.add(scene.getObjectByName("bow1"));
	
	players.push(player1.torso,player1.head,player1.leftShoulder,player1.rightShoulder,player1.leftArm
	,player1.rightArm,player1.rightHand,player1.leftHand,player1.lowerTorso,player1.waist,player1.leftThigh
	,player1.rightThigh,player1.leftCalf,player1.rightCalf,player1.leftFoot,player1.rightFoot);
	scene.add(player1.torsoDummy);

	// Add player two
	player2 = new Player(0x0000ff, new THREE.Vector3(0, 84, 1125), new THREE.Euler(0, 1.5708 * 2, 0));
	player2.leftHandDummy.add(scene.getObjectByName("bow2"));

	players.push(player2.torso,player2.head,player2.leftShoulder,player2.rightShoulder,player2.leftArm
	,player2.rightArm,player2.rightHand,player2.leftHand,player2.lowerTorso,player2.waist,player2.leftThigh
	,player2.rightThigh,player2.leftCalf,player2.rightCalf,player2.leftFoot,player2.rightFoot);
	scene.add(player2.torsoDummy);

	console.log(player1.leftHandDummy.children);
	console.log(player2.leftHandDummy.children);
}

function distance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}

function getMapSector(v) {
	var x = Math.floor((v.x + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	var z = Math.floor((v.z + UNIT_SIZE / 2) / UNIT_SIZE + mapW/2);
	return {x: x, z: z};
}

function checkWallCollision(v) {
	var c = getMapSector(v);
	return map[c.x][c.z] > 0;
}

function onDocumentMouseDown(e) {

	// Reset the power and arrow speed.
	//console.log(raycaster.ray.origin);
	pow = .1;
	ARROW_SPEED = 1;
	$('.power').css({width: 0+"%",});
	$('.power-bar').css({value: 0,});
	// Prevent infinite loop.
	if(mousedownID == -1) {
		mousedownID = setInterval(whileMouseDown, 100 /*execute every 100ms*/);
	}  
}

function whileMouseDown() {
	if(cam.position.z < 0)
	{
		physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/ARROW_SPEED*1.3, (wind.z/(2*Math.PI))+ARROW_SPEED) );
	}
	else
	{
		physicsWorld.setGravity( new Ammo.btVector3( wind.x/(2*Math.PI), - GRAVITY/ARROW_SPEED*1.3, (wind.z/(2*Math.PI))-ARROW_SPEED) );
	}
	

	// Grab CSS of the power bar.
	var value = $('.power-bar').data('value');
	var total = $('.power-bar').data('total');
	
	// Update the value based on power.
    var newValue = pow;
	pow += .05;
	var barWidth = (newValue / total) * 100;
  
	if(pow * 100 < 100) {
		var hitWidth = (pow) * 100 + "%";
		// While holding mouse down, increase arrow power.
		ARROW_SPEED += .5;
	}
    else {
		var hitWidth = 100 + "%";
	}
    // Update the data of the CSS.
	$('.power').css({width: hitWidth,});
	$('.power-bar').css({value: newValue,});
}

function onDocumentMouseMove(e)
{
	mouseCoords.set(
		 ( event.clientX / window.innerWidth ) * 2 - 1, // Set Mouse x-coordinates
		-( event.clientY / window.innerHeight ) * 2 + 1 // Set Mouse y-coordinates
	);
}

function onDocumentMouseUp(e) {
	if(mousedownID != -1) 
	{  //Only stop if exists
	  clearInterval(mousedownID);
	  mousedownID = -1;
	}
	
	raycaster.setFromCamera( mouseCoords, cam );
	
	// Creates a ball and throws it
	var ballMass = 1;
	var ballRadius = 2;

	var loader = new THREE.PLYLoader();
	loader.load( 'models/Arrow.ply', function ( geometry ) {
		geometry.computeVertexNormals();
		var material = new THREE.MeshStandardMaterial( { color: 0x130d06, flatShading: true } );
		var mesh3 = new THREE.Mesh( geometry, material );
		mesh3.position.y = 100;
		mesh3.position.x = -100;
		mesh3.position.z = 900;
		//mesh3.rotation.z += (1.5708); 
		mesh3.rotation = raycaster.ray.direction;
		mesh3.scale.multiplyScalar( 10.0 );
		mesh3.scale.x = 4;
		mesh3.castShadow = true;
		mesh3.receiveShadow = true;

		var ballShape = new Ammo.btSphereShape( ballRadius );
		ballShape.setMargin( margin );
		
		pos.copy( raycaster.ray.direction );
		pos.add( raycaster.ray.origin );
		
		quat.set( 0, 0, 0, 1 );
		
		var ballBody = createRigidBody( mesh3, ballShape, ballMass, pos, quat );
		pos.copy( raycaster.ray.direction );
		pos.multiplyScalar( 24 );
		
		ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	});
}


// Handle window resizing
$(window).resize(function() 
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	
	ASPECT_RATIO = WIDTH / HEIGHT;
	
	if (cam) {
		cam.aspect = ASPECT_RATIO;
		cam.updateProjectionMatrix();
	}

	if (renderer) {
		renderer.setSize(WIDTH, HEIGHT);
	}
	
	$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
});

// Stop moving around when the window is unfocused (keeps my sanity!)
$(window).focus(function() {
	if (controls) controls.freeze = false; 
});
$(window).blur(function() {
	if (controls) controls.freeze = true;
});
	
function removeDebris(object) {
	scene.remove( object );
	physicsWorld.removeRigidBody( object.userData.physicsBody );
}


function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) 
{
	if (pos) {
		object.position.copy( pos );
	} else {
		pos = object.position;
	}

	if (quat) {
		object.quaternion.copy( quat );
	} else {
		quat = object.quaternion;
	}
	
	var transform = new Ammo.btTransform();

	transform.setIdentity();
	transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
	transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
	
	var motionState = new Ammo.btDefaultMotionState( transform );
	var localInertia = new Ammo.btVector3( 0, 0, 0 );
	
	physicsShape.calculateLocalInertia( mass, localInertia );
	
	var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
	var body = new Ammo.btRigidBody( rbInfo );
	
	body.setFriction( 0.5 );

	if ( vel ) {
		
		body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
		
	}
	
	if ( angVel ) {
		body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );
	}
	
	object.userData.physicsBody = body;
	object.userData.collided = false;
	scene.add( object );
	
	if ( mass > 0 ) {
		rigidBodies.push( object );
		body.setActivationState( 4 ); // Disable deactivation
	}
	
	//https://stackoverflow.com/questions/18370701/how-to-draw-the-trajectory-of-a-mesh-with-threejs
	physicsWorld.addRigidBody( body );

	return body;
}

function initPhysics() {
	// Physics configuration
	collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
	
	dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
	broadphase = new Ammo.btDbvtBroadphase();
	solver = new Ammo.btSequentialImpulseConstraintSolver();
	
	physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
	physicsWorld.setGravity( new Ammo.btVector3( 0, -GRAVITY/50, 0) );
}

function updatePhysics( deltaTime ) 
{
	// Step world
	physicsWorld.stepSimulation( deltaTime, 10 );
	
	// Update rigid bodies
	for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
		var objThree = rigidBodies[ i ];
		var objPhys = objThree.userData.physicsBody;
		
		var ms = objPhys.getMotionState();
		
		if ( ms ) {
			ms.getWorldTransform( transformAux1 );
			
			var p = transformAux1.getOrigin();
			var q = transformAux1.getRotation();
			
			objThree.position.set(p.x(), p.y(), p.z());
			if(cam.position.z < 0)
			{
				objThree.rotation.y = (4.7124);
				objThree.userData.collided = false;
			}
			else
			{
				objThree.rotation.y = (-4.7124);
				objThree.userData.collided = false;
			}
			//objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
			
		}
	}

	for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {
		
		var contactManifold = dispatcher.getManifoldByIndexInternal( i );
		
		var rb0 = contactManifold.getBody0();
		var rb1 = contactManifold.getBody1();
		
		var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
		var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;
		
		if ( ! threeObject0 && ! threeObject1 ) 
		{
			continue;
		}
		
		var userData0 = threeObject0 ? threeObject0.userData : null;
		var userData1 = threeObject1 ? threeObject1.userData : null;
		
		var breakable0 = userData0 ? userData0.breakable : false;
		var breakable1 = userData1 ? userData1.breakable : false;
		
		var collided0 = userData0 ? userData0.collided : false;
		var collided1 = userData1 ? userData1.collided : false;
		
		if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
			continue;
		}

		var contact = false;
		var maxImpulse = 0;
		
		for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {
			var contactPoint = contactManifold.getContactPoint( j );
			
			if ( contactPoint.getDistance() < 0 ) {
				contact = true;
				
				var impulse = contactPoint.getAppliedImpulse();
				
				if ( impulse > maxImpulse ) {
					maxImpulse = impulse;
					
					var pos = contactPoint.get_m_positionWorldOnB();
					var normal = contactPoint.get_m_normalWorldOnB();
					
					impactPoint.set( pos.x(), pos.y(), pos.z() );
					impactNormal.set( normal.x(), normal.y(), normal.z() );
				}

				break;
			}
		}

		// If no point has contact, abort
		if (!contact) continue;

		// Subdivision
		var fractureImpulse = 250;
		
		if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) {
				createDebrisFromBreakableObject( debris[ j ] );
			}

			objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
			
			userData0.collided = true;
		}
		
		if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) {
			var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );
			
			var numObjects = debris.length;
			for ( var j = 0; j < numObjects; j++ ) 
			{
				createDebrisFromBreakableObject( debris[ j ] );
			}
			
			objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
			
			userData1.collided = true;
		}
	}

	for ( var i = 0; i < numObjectsToRemove; i++ ) {
		removeDebris( objectsToRemove[ i ] );
	}

	numObjectsToRemove = 0;
}

function initWind() {
	wind = new THREE.Vector3(getRandomArbitrary(-2*Math.PI, 2*Math.PI), 1, getRandomArbitrary(-2*Math.PI, 2*Math.PI));
	//console.log(wind.x,wind.y,wind.z);
}

function createRandomColor() {
	return Math.floor( Math.random() * ( 1 << 24 ) );
}

function createMaterial( color ) {
	color = color || createRandomColor();
	return new THREE.MeshPhongMaterial( { color: color } );
}

function getRandomArbitrary(min, max) {
	return Math.random() * (max - min) + min;
}

// function getQuadraticBezierXYatT(startPt,controlPt,endPt,T) {
//     var x = Math.pow(1-T,2) * startPt.x + 2 * (1-T) * T * controlPt.x + Math.pow(T,2) * endPt.x; 
//     var y = Math.pow(1-T,2) * startPt.y + 2 * (1-T) * T * controlPt.y + Math.pow(T,2) * endPt.y; 
//     return( {x:x,y:y} );
// }
</script>
</html>